
C:\Users\Lenovo\AppData\Local\Temp\arduino\sketches\D97641F287D50FFB97DB02DAA270C830/ldr.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	46 c0       	rjmp	.+140    	; 0x8e <__dtors_end>
   2:	6a c0       	rjmp	.+212    	; 0xd8 <__bad_interrupt>
   4:	69 c0       	rjmp	.+210    	; 0xd8 <__bad_interrupt>
   6:	68 c0       	rjmp	.+208    	; 0xd8 <__bad_interrupt>
   8:	67 c0       	rjmp	.+206    	; 0xd8 <__bad_interrupt>
   a:	66 c0       	rjmp	.+204    	; 0xd8 <__bad_interrupt>
   c:	65 c0       	rjmp	.+202    	; 0xd8 <__bad_interrupt>
   e:	64 c0       	rjmp	.+200    	; 0xd8 <__bad_interrupt>
  10:	63 c0       	rjmp	.+198    	; 0xd8 <__bad_interrupt>
  12:	5c c2       	rjmp	.+1208   	; 0x4cc <__vector_9>
  14:	61 c0       	rjmp	.+194    	; 0xd8 <__bad_interrupt>
  16:	c9 c2       	rjmp	.+1426   	; 0x5aa <__vector_11>
  18:	a3 c2       	rjmp	.+1350   	; 0x560 <__vector_12>
  1a:	5e c0       	rjmp	.+188    	; 0xd8 <__bad_interrupt>
  1c:	5d c0       	rjmp	.+186    	; 0xd8 <__bad_interrupt>
  1e:	5c c0       	rjmp	.+184    	; 0xd8 <__bad_interrupt>
  20:	5b c0       	rjmp	.+182    	; 0xd8 <__bad_interrupt>
  22:	f5 c2       	rjmp	.+1514   	; 0x60e <__vector_17>
  24:	59 c0       	rjmp	.+178    	; 0xd8 <__bad_interrupt>

00000026 <__trampolines_end>:
__trampolines_start():
  26:	00 00       	nop
  28:	00 00       	nop
  2a:	37 00       	.word	0x0037	; ????
  2c:	34 00       	.word	0x0034	; ????
  2e:	31 00       	.word	0x0031	; ????

00000030 <digital_pin_to_timer_PGM>:
	...
  38:	00 04 05 07 00 00 00 00 00 00 00 00 00 00 00        ...............

00000047 <port_to_input_PGM>:
  47:	00 00 00 00 36 00 33 00 30 00                       ....6.3.0.

00000051 <digital_pin_to_bit_mask_PGM>:
  51:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
  61:	04 08 10 20 40 80 40                                ... @.@

00000068 <port_to_output_PGM>:
  68:	00 00 00 00 38 00 35 00 32 00                       ....8.5.2.

00000072 <digital_pin_to_port_PGM>:
  72:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
  82:	03 03 03 03 02 02 03 00                             ........

0000008a <__ctors_start>:
__ctors_start():
  8a:	12 04       	cpc	r1, r2

0000008c <__ctors_end>:
__dtors_start():
  8c:	1a 06       	cpc	r1, r26

0000008e <__dtors_end>:
__dtors_end():
  8e:	11 24       	eor	r1, r1
  90:	1f be       	out	0x3f, r1	; 63
  92:	cf e5       	ldi	r28, 0x5F	; 95
  94:	d4 e0       	ldi	r29, 0x04	; 4
  96:	de bf       	out	0x3e, r29	; 62
  98:	cd bf       	out	0x3d, r28	; 61

0000009a <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  9a:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  9c:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  9e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  a0:	ee e5       	ldi	r30, 0x5E	; 94
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  a2:	ff e0       	ldi	r31, 0x0F	; 15
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  a4:	02 c0       	rjmp	.+4      	; 0xaa <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  a6:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  a8:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  aa:	a2 38       	cpi	r26, 0x82	; 130
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  ac:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  ae:	d9 f7       	brne	.-10     	; 0xa6 <__do_copy_data+0xc>

000000b0 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  b0:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  b2:	a2 e8       	ldi	r26, 0x82	; 130
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  b4:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  b6:	01 c0       	rjmp	.+2      	; 0xba <.do_clear_bss_start>

000000b8 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  b8:	1d 92       	st	X+, r1

000000ba <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  ba:	aa 3b       	cpi	r26, 0xBA	; 186
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  bc:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  be:	e1 f7       	brne	.-8      	; 0xb8 <.do_clear_bss_loop>

000000c0 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  c0:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  c2:	c6 e4       	ldi	r28, 0x46	; 70
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  c4:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  c6:	03 c0       	rjmp	.+6      	; 0xce <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  c8:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  ca:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  cc:	11 d6       	rcall	.+3106   	; 0xcf0 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  ce:	c5 34       	cpi	r28, 0x45	; 69
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  d0:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  d2:	d1 f7       	brne	.-12     	; 0xc8 <__do_global_ctors+0x8>
  d4:	9a d4       	rcall	.+2356   	; 0xa0a <main>
  d6:	37 c7       	rjmp	.+3694   	; 0xf46 <__do_global_dtors>

000000d8 <__bad_interrupt>:
__vector_1():
  d8:	93 cf       	rjmp	.-218    	; 0x0 <__vectors>

000000da <digitalWrite>:
digitalWrite():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:189
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  uint8_t timer = digitalPinToTimer(pin);
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	fc 01       	movw	r30, r24
  de:	e0 5d       	subi	r30, 0xD0	; 208
  e0:	ff 4f       	sbci	r31, 0xFF	; 255
  e2:	34 91       	lpm	r19, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:190
  uint8_t bit = digitalPinToBitMask(pin);
  e4:	fc 01       	movw	r30, r24
  e6:	ef 5a       	subi	r30, 0xAF	; 175
  e8:	ff 4f       	sbci	r31, 0xFF	; 255
  ea:	24 91       	lpm	r18, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:191
  uint8_t port = digitalPinToPort(pin);
  ec:	fc 01       	movw	r30, r24
  ee:	ee 58       	subi	r30, 0x8E	; 142
  f0:	ff 4f       	sbci	r31, 0xFF	; 255
  f2:	e4 91       	lpm	r30, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:194
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
  f4:	ee 23       	and	r30, r30
  f6:	e1 f0       	breq	.+56     	; 0x130 <digitalWrite+0x56>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:198

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  f8:	33 23       	and	r19, r19
  fa:	49 f0       	breq	.+18     	; 0x10e <digitalWrite+0x34>
turnOffPWM():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:77
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
  switch (timer)
  fc:	35 30       	cpi	r19, 0x05	; 5
  fe:	c9 f0       	breq	.+50     	; 0x132 <digitalWrite+0x58>
 100:	37 30       	cpi	r19, 0x07	; 7
 102:	d1 f0       	breq	.+52     	; 0x138 <digitalWrite+0x5e>
 104:	34 30       	cpi	r19, 0x04	; 4
 106:	19 f4       	brne	.+6      	; 0x10e <digitalWrite+0x34>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:82
  {
    // Timer1
    #if defined(TCCR1A) && defined(COM1A1)
      case TIMER1A:
        TCCR1A &= ~_BV(COM1A1);
 108:	8f b5       	in	r24, 0x2f	; 47
 10a:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:87
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
 10c:	8f bd       	out	0x2f, r24	; 47
digitalWrite():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:200

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	ee 0f       	add	r30, r30
 112:	ff 1f       	adc	r31, r31
 114:	e8 59       	subi	r30, 0x98	; 152
 116:	ff 4f       	sbci	r31, 0xFF	; 255
 118:	a5 91       	lpm	r26, Z+
 11a:	b4 91       	lpm	r27, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:202

  uint8_t oldSREG = SREG;
 11c:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:203
  cli();
 11e:	f8 94       	cli
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:205

  if (val == LOW) {
 120:	61 11       	cpse	r22, r1
 122:	0e c0       	rjmp	.+28     	; 0x140 <digitalWrite+0x66>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:206
    *out &= ~bit;
 124:	9c 91       	ld	r25, X
 126:	e2 2f       	mov	r30, r18
 128:	e0 95       	com	r30
 12a:	e9 23       	and	r30, r25
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:208
  } else {
    *out |= bit;
 12c:	ec 93       	st	X, r30
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:211
  }

  SREG = oldSREG;
 12e:	8f bf       	out	0x3f, r24	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:212
}
 130:	08 95       	ret
turnOffPWM():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:87
        TCCR1A &= ~_BV(COM1A1);
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
 132:	8f b5       	in	r24, 0x2f	; 47
 134:	8f 7d       	andi	r24, 0xDF	; 223
 136:	ea cf       	rjmp	.-44     	; 0x10c <digitalWrite+0x32>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:99
    #endif
    
    // Timer2
    #if defined(TCCR2) && defined(COM21)
      case TIMER2:
        TCCR2 &= ~_BV(COM21);
 138:	85 b5       	in	r24, 0x25	; 37
 13a:	8f 7d       	andi	r24, 0xDF	; 223
 13c:	85 bd       	out	0x25, r24	; 37
 13e:	e7 cf       	rjmp	.-50     	; 0x10e <digitalWrite+0x34>
digitalWrite():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:208
  cli();

  if (val == LOW) {
    *out &= ~bit;
  } else {
    *out |= bit;
 140:	ec 91       	ld	r30, X
 142:	e2 2b       	or	r30, r18
 144:	f3 cf       	rjmp	.-26     	; 0x12c <digitalWrite+0x52>

00000146 <pinMode>:
pinMode():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:30
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 146:	cf 93       	push	r28
 148:	df 93       	push	r29
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:31
  uint8_t bit = digitalPinToBitMask(pin);
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	fc 01       	movw	r30, r24
 14e:	ef 5a       	subi	r30, 0xAF	; 175
 150:	ff 4f       	sbci	r31, 0xFF	; 255
 152:	24 91       	lpm	r18, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:32
  uint8_t port = digitalPinToPort(pin);
 154:	8e 58       	subi	r24, 0x8E	; 142
 156:	9f 4f       	sbci	r25, 0xFF	; 255
 158:	fc 01       	movw	r30, r24
 15a:	84 91       	lpm	r24, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:35
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 15c:	88 23       	and	r24, r24
 15e:	d1 f0       	breq	.+52     	; 0x194 <pinMode+0x4e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:38

  // JWS: can I let the optimizer do this?
  reg = portModeRegister(port);
 160:	90 e0       	ldi	r25, 0x00	; 0
 162:	88 0f       	add	r24, r24
 164:	99 1f       	adc	r25, r25
 166:	fc 01       	movw	r30, r24
 168:	ea 5d       	subi	r30, 0xDA	; 218
 16a:	ff 4f       	sbci	r31, 0xFF	; 255
 16c:	a5 91       	lpm	r26, Z+
 16e:	b4 91       	lpm	r27, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:39
  out = portOutputRegister(port);
 170:	fc 01       	movw	r30, r24
 172:	e8 59       	subi	r30, 0x98	; 152
 174:	ff 4f       	sbci	r31, 0xFF	; 255
 176:	c5 91       	lpm	r28, Z+
 178:	d4 91       	lpm	r29, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:41

  if (mode == INPUT) { 
 17a:	61 11       	cpse	r22, r1
 17c:	0e c0       	rjmp	.+28     	; 0x19a <pinMode+0x54>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:42
    uint8_t oldSREG = SREG;
 17e:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:43
    cli();
 180:	f8 94       	cli
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:44
    *reg &= ~bit;
 182:	8c 91       	ld	r24, X
 184:	e2 2f       	mov	r30, r18
 186:	e0 95       	com	r30
 188:	8e 23       	and	r24, r30
 18a:	8c 93       	st	X, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:45
    *out &= ~bit;
 18c:	28 81       	ld	r18, Y
 18e:	e2 23       	and	r30, r18
 190:	e8 83       	st	Y, r30
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:46
    SREG = oldSREG;
 192:	9f bf       	out	0x3f, r25	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:59
    uint8_t oldSREG = SREG;
    cli();
    *reg |= bit;
    SREG = oldSREG;
  }
}
 194:	df 91       	pop	r29
 196:	cf 91       	pop	r28
 198:	08 95       	ret
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:54
    cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 19a:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:55
    cli();
 19c:	f8 94       	cli
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:56
    *reg |= bit;
 19e:	ec 91       	ld	r30, X
 1a0:	e2 2b       	or	r30, r18
 1a2:	ec 93       	st	X, r30
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:57
    SREG = oldSREG;
 1a4:	8f bf       	out	0x3f, r24	; 63
 1a6:	f6 cf       	rjmp	.-20     	; 0x194 <pinMode+0x4e>

000001a8 <micros>:
micros():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:237
  unsigned char f; // temporary storage for millis fraction counter
  unsigned char q = 0; // record whether an overflow is flagged
#endif
  // t will be the number where the timer0 counter stopped
  uint8_t t;
  uint8_t oldSREG = SREG;
 1a8:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:240

  // Stop all interrupts
  cli();
 1aa:	f8 94       	cli
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:247
#ifdef CORRECT_EXACT_MICROS
  // combine exact millisec and 8usec counters
  m = timer0_millis;
  f = timer0_fract;
#else
  m = timer0_overflow_count;
 1ac:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <timer0_overflow_count>
 1b0:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <timer0_overflow_count+0x1>
 1b4:	a0 91 dc 00 	lds	r26, 0x00DC	; 0x8000dc <timer0_overflow_count+0x2>
 1b8:	b0 91 dd 00 	lds	r27, 0x00DD	; 0x8000dd <timer0_overflow_count+0x3>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:252
#endif

  // TCNT0 : The Timer Counter Register
#if defined(TCNT0)
  t = TCNT0;
 1bc:	22 b7       	in	r18, 0x32	; 50
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:268
    m++;
#else
    q = 1;
#endif
#else
  if ((TIFR & _BV(TOV0)) && (t < 255))
 1be:	08 b6       	in	r0, 0x38	; 56
 1c0:	00 fe       	sbrs	r0, 0
 1c2:	05 c0       	rjmp	.+10     	; 0x1ce <micros+0x26>
 1c4:	2f 3f       	cpi	r18, 0xFF	; 255
 1c6:	19 f0       	breq	.+6      	; 0x1ce <micros+0x26>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:270
#ifndef CORRECT_EXACT_MICROS
    m++;
 1c8:	01 96       	adiw	r24, 0x01	; 1
 1ca:	a1 1d       	adc	r26, r1
 1cc:	b1 1d       	adc	r27, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:276
#else
    q = 1;
#endif
#endif
  // Restore SREG
  SREG = oldSREG;
 1ce:	3f bf       	out	0x3f, r19	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:292
      ((t * MICROSECONDS_PER_TIMER0_OVERFLOW) >> 8);
  return q ? m + MICROSECONDS_PER_TIMER0_OVERFLOW : m;
#elif 1
  /* All power-of-two Megahertz frequencies enter here, as well as 12.8 MHz.
     We only end up here if right shift before multiplication is exact. */
  return ((m << 8) + t) * (MICROSECONDS_PER_TIMER0_OVERFLOW >> 8);
 1d0:	ba 2f       	mov	r27, r26
 1d2:	a9 2f       	mov	r26, r25
 1d4:	98 2f       	mov	r25, r24
 1d6:	88 27       	eor	r24, r24
 1d8:	bc 01       	movw	r22, r24
 1da:	cd 01       	movw	r24, r26
 1dc:	62 0f       	add	r22, r18
 1de:	71 1d       	adc	r23, r1
 1e0:	81 1d       	adc	r24, r1
 1e2:	91 1d       	adc	r25, r1
 1e4:	42 e0       	ldi	r20, 0x02	; 2
 1e6:	66 0f       	add	r22, r22
 1e8:	77 1f       	adc	r23, r23
 1ea:	88 1f       	adc	r24, r24
 1ec:	99 1f       	adc	r25, r25
 1ee:	4a 95       	dec	r20
 1f0:	d1 f7       	brne	.-12     	; 0x1e6 <micros+0x3e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:393
  // m & t are multiplied by 4 (since it was already multiplied by 256)
  // t is multiplied by 4
  return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
#endif
#endif // 0
}
 1f2:	08 95       	ret

000001f4 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:35

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 1f4:	af 92       	push	r10
 1f6:	bf 92       	push	r11
 1f8:	cf 92       	push	r12
 1fa:	df 92       	push	r13
 1fc:	ef 92       	push	r14
 1fe:	ff 92       	push	r15
 200:	0f 93       	push	r16
 202:	1f 93       	push	r17
 204:	cf 93       	push	r28
 206:	df 93       	push	r29
 208:	6c 01       	movw	r12, r24
 20a:	7b 01       	movw	r14, r22
 20c:	8b 01       	movw	r16, r22
 20e:	04 0f       	add	r16, r20
 210:	15 1f       	adc	r17, r21
 212:	eb 01       	movw	r28, r22
 214:	5e 01       	movw	r10, r28
 216:	ae 18       	sub	r10, r14
 218:	bf 08       	sbc	r11, r15
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:37
  size_t n = 0;
  while (size--) {
 21a:	c0 17       	cp	r28, r16
 21c:	d1 07       	cpc	r29, r17
 21e:	59 f0       	breq	.+22     	; 0x236 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:38
    if (write(*buffer++)) n++;
 220:	69 91       	ld	r22, Y+
 222:	d6 01       	movw	r26, r12
 224:	ed 91       	ld	r30, X+
 226:	fc 91       	ld	r31, X
 228:	01 90       	ld	r0, Z+
 22a:	f0 81       	ld	r31, Z
 22c:	e0 2d       	mov	r30, r0
 22e:	c6 01       	movw	r24, r12
 230:	09 95       	icall
 232:	89 2b       	or	r24, r25
 234:	79 f7       	brne	.-34     	; 0x214 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:42
    else break;
  }
  return n;
}
 236:	c5 01       	movw	r24, r10
 238:	df 91       	pop	r29
 23a:	cf 91       	pop	r28
 23c:	1f 91       	pop	r17
 23e:	0f 91       	pop	r16
 240:	ff 90       	pop	r15
 242:	ef 90       	pop	r14
 244:	df 90       	pop	r13
 246:	cf 90       	pop	r12
 248:	bf 90       	pop	r11
 24a:	af 90       	pop	r10
 24c:	08 95       	ret

0000024e <HardwareSerial::availableForWrite()>:
_ZN14HardwareSerial17availableForWriteEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:195
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
 24e:	fc 01       	movw	r30, r24
 250:	53 8d       	ldd	r21, Z+27	; 0x1b
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:196
    tail = _tx_buffer_tail;
 252:	44 8d       	ldd	r20, Z+28	; 0x1c
 254:	25 2f       	mov	r18, r21
 256:	30 e0       	ldi	r19, 0x00	; 0
 258:	84 2f       	mov	r24, r20
 25a:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:198
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 25c:	82 1b       	sub	r24, r18
 25e:	93 0b       	sbc	r25, r19
 260:	54 17       	cp	r21, r20
 262:	10 f0       	brcs	.+4      	; 0x268 <HardwareSerial::availableForWrite()+0x1a>
 264:	cf 96       	adiw	r24, 0x3f	; 63
 266:	08 95       	ret
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:199
  return tail - head - 1;
 268:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:200
}
 26a:	08 95       	ret

0000026c <HardwareSerial::read()>:
_ZN14HardwareSerial4readEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:178
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
 26c:	fc 01       	movw	r30, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:180
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 26e:	91 8d       	ldd	r25, Z+25	; 0x19
 270:	82 8d       	ldd	r24, Z+26	; 0x1a
 272:	98 17       	cp	r25, r24
 274:	61 f0       	breq	.+24     	; 0x28e <HardwareSerial::read()+0x22>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:183
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 276:	a2 8d       	ldd	r26, Z+26	; 0x1a
 278:	ae 0f       	add	r26, r30
 27a:	bf 2f       	mov	r27, r31
 27c:	b1 1d       	adc	r27, r1
 27e:	5d 96       	adiw	r26, 0x1d	; 29
 280:	8c 91       	ld	r24, X
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:184
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 282:	92 8d       	ldd	r25, Z+26	; 0x1a
 284:	9f 5f       	subi	r25, 0xFF	; 255
 286:	9f 73       	andi	r25, 0x3F	; 63
 288:	92 8f       	std	Z+26, r25	; 0x1a
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:185
    return c;
 28a:	90 e0       	ldi	r25, 0x00	; 0
 28c:	08 95       	ret
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:181

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 28e:	8f ef       	ldi	r24, 0xFF	; 255
 290:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:187
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 292:	08 95       	ret

00000294 <HardwareSerial::peek()>:
_ZN14HardwareSerial4peekEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:169
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
 294:	fc 01       	movw	r30, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:170
  if (_rx_buffer_head == _rx_buffer_tail) {
 296:	91 8d       	ldd	r25, Z+25	; 0x19
 298:	82 8d       	ldd	r24, Z+26	; 0x1a
 29a:	98 17       	cp	r25, r24
 29c:	31 f0       	breq	.+12     	; 0x2aa <HardwareSerial::peek()+0x16>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:173
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 29e:	82 8d       	ldd	r24, Z+26	; 0x1a
 2a0:	e8 0f       	add	r30, r24
 2a2:	f1 1d       	adc	r31, r1
 2a4:	85 8d       	ldd	r24, Z+29	; 0x1d
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	08 95       	ret
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:171
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 2aa:	8f ef       	ldi	r24, 0xFF	; 255
 2ac:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:175
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 2ae:	08 95       	ret

000002b0 <HardwareSerial::available()>:
_ZN14HardwareSerial9availableEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:164
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 2b0:	fc 01       	movw	r30, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:165
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 2b2:	91 8d       	ldd	r25, Z+25	; 0x19
 2b4:	22 8d       	ldd	r18, Z+26	; 0x1a
 2b6:	89 2f       	mov	r24, r25
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	80 5c       	subi	r24, 0xC0	; 192
 2bc:	9f 4f       	sbci	r25, 0xFF	; 255
 2be:	82 1b       	sub	r24, r18
 2c0:	91 09       	sbc	r25, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:166
}
 2c2:	8f 73       	andi	r24, 0x3F	; 63
 2c4:	99 27       	eor	r25, r25
 2c6:	08 95       	ret

000002c8 <Serial0_available()>:
_Z17Serial0_availablev():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:76
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 2c8:	8e ed       	ldi	r24, 0xDE	; 222
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	f1 df       	rcall	.-30     	; 0x2b0 <HardwareSerial::available()>
 2ce:	21 e0       	ldi	r18, 0x01	; 1
 2d0:	89 2b       	or	r24, r25
 2d2:	09 f4       	brne	.+2      	; 0x2d6 <Serial0_available()+0xe>
 2d4:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:77
}
 2d6:	82 2f       	mov	r24, r18
 2d8:	08 95       	ret

000002da <serialEventRun()>:
_Z14serialEventRunv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 2da:	80 e0       	ldi	r24, 0x00	; 0
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	89 2b       	or	r24, r25
 2e0:	19 f0       	breq	.+6      	; 0x2e8 <serialEventRun()+0xe>
 2e2:	f2 df       	rcall	.-28     	; 0x2c8 <Serial0_available()>
 2e4:	81 11       	cpse	r24, r1
 2e6:	8c ce       	rjmp	.-744    	; 0x0 <__vectors>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:78
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
 2e8:	08 95       	ret

000002ea <HardwareSerial::_tx_udr_empty_irq()>:
_ZN14HardwareSerial17_tx_udr_empty_irqEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:90
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 2ea:	fc 01       	movw	r30, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:93
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 2ec:	a4 8d       	ldd	r26, Z+28	; 0x1c
 2ee:	a8 0f       	add	r26, r24
 2f0:	b9 2f       	mov	r27, r25
 2f2:	b1 1d       	adc	r27, r1
 2f4:	a3 5a       	subi	r26, 0xA3	; 163
 2f6:	bf 4f       	sbci	r27, 0xFF	; 255
 2f8:	2c 91       	ld	r18, X
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:94
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 2fa:	84 8d       	ldd	r24, Z+28	; 0x1c
 2fc:	90 e0       	ldi	r25, 0x00	; 0
 2fe:	01 96       	adiw	r24, 0x01	; 1
 300:	8f 73       	andi	r24, 0x3F	; 63
 302:	99 27       	eor	r25, r25
 304:	84 8f       	std	Z+28, r24	; 0x1c
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:96

  *_udr = c;
 306:	a6 89       	ldd	r26, Z+22	; 0x16
 308:	b7 89       	ldd	r27, Z+23	; 0x17
 30a:	2c 93       	st	X, r18
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:106
  // written to the rest.

  #ifdef MPCM0
    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
  #else
    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
 30c:	a0 89       	ldd	r26, Z+16	; 0x10
 30e:	b1 89       	ldd	r27, Z+17	; 0x11
 310:	8c 91       	ld	r24, X
 312:	82 74       	andi	r24, 0x42	; 66
 314:	8c 93       	st	X, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:109
  #endif

  if (_tx_buffer_head == _tx_buffer_tail) {
 316:	93 8d       	ldd	r25, Z+27	; 0x1b
 318:	84 8d       	ldd	r24, Z+28	; 0x1c
 31a:	98 13       	cpse	r25, r24
 31c:	06 c0       	rjmp	.+12     	; 0x32a <HardwareSerial::_tx_udr_empty_irq()+0x40>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:111
    // Buffer empty, so disable interrupts
    *_ucsrb &= ~_BV(UDRIE0);
 31e:	02 88       	ldd	r0, Z+18	; 0x12
 320:	f3 89       	ldd	r31, Z+19	; 0x13
 322:	e0 2d       	mov	r30, r0
 324:	80 81       	ld	r24, Z
 326:	8f 7d       	andi	r24, 0xDF	; 223
 328:	80 83       	st	Z, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:113
  }
}
 32a:	08 95       	ret

0000032c <HardwareSerial::write(unsigned char)>:
_ZN14HardwareSerial5writeEh():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:223
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
 32c:	ef 92       	push	r14
 32e:	ff 92       	push	r15
 330:	0f 93       	push	r16
 332:	1f 93       	push	r17
 334:	cf 93       	push	r28
 336:	df 93       	push	r29
 338:	ec 01       	movw	r28, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:224
  _written = true;
 33a:	81 e0       	ldi	r24, 0x01	; 1
 33c:	88 8f       	std	Y+24, r24	; 0x18
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:229
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 33e:	9b 8d       	ldd	r25, Y+27	; 0x1b
 340:	8c 8d       	ldd	r24, Y+28	; 0x1c
 342:	98 13       	cpse	r25, r24
 344:	19 c0       	rjmp	.+50     	; 0x378 <HardwareSerial::write(unsigned char)+0x4c>
 346:	e8 89       	ldd	r30, Y+16	; 0x10
 348:	f9 89       	ldd	r31, Y+17	; 0x11
 34a:	80 81       	ld	r24, Z
 34c:	85 ff       	sbrs	r24, 5
 34e:	14 c0       	rjmp	.+40     	; 0x378 <HardwareSerial::write(unsigned char)+0x4c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:238
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 350:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\lenovo\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 352:	f8 94       	cli
_ZN14HardwareSerial5writeEh():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:239
      *_udr = c;
 354:	ee 89       	ldd	r30, Y+22	; 0x16
 356:	ff 89       	ldd	r31, Y+23	; 0x17
 358:	60 83       	st	Z, r22
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:243
      #ifdef MPCM0
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
      #else
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
 35a:	e8 89       	ldd	r30, Y+16	; 0x10
 35c:	f9 89       	ldd	r31, Y+17	; 0x11
 35e:	80 81       	ld	r24, Z
 360:	82 74       	andi	r24, 0x42	; 66
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:271
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    *_ucsrb |= _BV(UDRIE0);
 362:	80 83       	st	Z, r24
__iRestore():
c:\users\lenovo\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:70
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 364:	9f bf       	out	0x3f, r25	; 63
_ZN14HardwareSerial5writeEh():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:275
  }
  
  return 1;
}
 366:	81 e0       	ldi	r24, 0x01	; 1
 368:	90 e0       	ldi	r25, 0x00	; 0
 36a:	df 91       	pop	r29
 36c:	cf 91       	pop	r28
 36e:	1f 91       	pop	r17
 370:	0f 91       	pop	r16
 372:	ff 90       	pop	r15
 374:	ef 90       	pop	r14
 376:	08 95       	ret
 378:	f6 2e       	mov	r15, r22
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:248
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
      #endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 37a:	0b 8d       	ldd	r16, Y+27	; 0x1b
 37c:	10 e0       	ldi	r17, 0x00	; 0
 37e:	0f 5f       	subi	r16, 0xFF	; 255
 380:	1f 4f       	sbci	r17, 0xFF	; 255
 382:	0f 73       	andi	r16, 0x3F	; 63
 384:	11 27       	eor	r17, r17
 386:	e0 2e       	mov	r14, r16
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:252

  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 388:	8c 8d       	ldd	r24, Y+28	; 0x1c
 38a:	8e 11       	cpse	r24, r14
 38c:	0b c0       	rjmp	.+22     	; 0x3a4 <HardwareSerial::write(unsigned char)+0x78>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:253
    if (bit_is_clear(SREG, SREG_I)) {
 38e:	0f b6       	in	r0, 0x3f	; 63
 390:	07 fc       	sbrc	r0, 7
 392:	fa cf       	rjmp	.-12     	; 0x388 <HardwareSerial::write(unsigned char)+0x5c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:258
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 394:	e8 89       	ldd	r30, Y+16	; 0x10
 396:	f9 89       	ldd	r31, Y+17	; 0x11
 398:	80 81       	ld	r24, Z
 39a:	85 ff       	sbrs	r24, 5
 39c:	f5 cf       	rjmp	.-22     	; 0x388 <HardwareSerial::write(unsigned char)+0x5c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:259
        _tx_udr_empty_irq();
 39e:	ce 01       	movw	r24, r28
 3a0:	a4 df       	rcall	.-184    	; 0x2ea <HardwareSerial::_tx_udr_empty_irq()>
 3a2:	f2 cf       	rjmp	.-28     	; 0x388 <HardwareSerial::write(unsigned char)+0x5c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:265
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 3a4:	eb 8d       	ldd	r30, Y+27	; 0x1b
 3a6:	ec 0f       	add	r30, r28
 3a8:	fd 2f       	mov	r31, r29
 3aa:	f1 1d       	adc	r31, r1
 3ac:	e3 5a       	subi	r30, 0xA3	; 163
 3ae:	ff 4f       	sbci	r31, 0xFF	; 255
 3b0:	f0 82       	st	Z, r15
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:269
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 3b2:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\lenovo\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 3b4:	f8 94       	cli
_ZN14HardwareSerial5writeEh():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:270
    _tx_buffer_head = i;
 3b6:	0b 8f       	std	Y+27, r16	; 0x1b
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:271
    *_ucsrb |= _BV(UDRIE0);
 3b8:	ea 89       	ldd	r30, Y+18	; 0x12
 3ba:	fb 89       	ldd	r31, Y+19	; 0x13
 3bc:	80 81       	ld	r24, Z
 3be:	80 62       	ori	r24, 0x20	; 32
 3c0:	d0 cf       	rjmp	.-96     	; 0x362 <HardwareSerial::write(unsigned char)+0x36>

000003c2 <HardwareSerial::flush()>:
_ZN14HardwareSerial5flushEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:203
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 3c2:	cf 93       	push	r28
 3c4:	df 93       	push	r29
 3c6:	ec 01       	movw	r28, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:207
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 3c8:	88 8d       	ldd	r24, Y+24	; 0x18
 3ca:	88 23       	and	r24, r24
 3cc:	b1 f0       	breq	.+44     	; 0x3fa <HardwareSerial::flush()+0x38>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:210
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 3ce:	aa 89       	ldd	r26, Y+18	; 0x12
 3d0:	bb 89       	ldd	r27, Y+19	; 0x13
 3d2:	e8 89       	ldd	r30, Y+16	; 0x10
 3d4:	f9 89       	ldd	r31, Y+17	; 0x11
 3d6:	8c 91       	ld	r24, X
 3d8:	85 fd       	sbrc	r24, 5
 3da:	03 c0       	rjmp	.+6      	; 0x3e2 <HardwareSerial::flush()+0x20>
 3dc:	80 81       	ld	r24, Z
 3de:	86 fd       	sbrc	r24, 6
 3e0:	0c c0       	rjmp	.+24     	; 0x3fa <HardwareSerial::flush()+0x38>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:211
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 3e2:	0f b6       	in	r0, 0x3f	; 63
 3e4:	07 fc       	sbrc	r0, 7
 3e6:	f7 cf       	rjmp	.-18     	; 0x3d6 <HardwareSerial::flush()+0x14>
 3e8:	8c 91       	ld	r24, X
 3ea:	85 ff       	sbrs	r24, 5
 3ec:	f2 cf       	rjmp	.-28     	; 0x3d2 <HardwareSerial::flush()+0x10>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:215
      // Interrupts are globally disabled, but the DR empty
      // interrupt should be enabled, so poll the DR empty flag to
      // prevent deadlock
      if (bit_is_set(*_ucsra, UDRE0))
 3ee:	80 81       	ld	r24, Z
 3f0:	85 ff       	sbrs	r24, 5
 3f2:	ed cf       	rjmp	.-38     	; 0x3ce <HardwareSerial::flush()+0xc>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:216
        _tx_udr_empty_irq();
 3f4:	ce 01       	movw	r24, r28
 3f6:	79 df       	rcall	.-270    	; 0x2ea <HardwareSerial::_tx_udr_empty_irq()>
 3f8:	ea cf       	rjmp	.-44     	; 0x3ce <HardwareSerial::flush()+0xc>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:220
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 3fa:	df 91       	pop	r29
 3fc:	cf 91       	pop	r28
 3fe:	08 95       	ret

00000400 <twi_stop>:
twi_stop():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:436
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 400:	85 ed       	ldi	r24, 0xD5	; 213
 402:	86 bf       	out	0x36, r24	; 54
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:456
          return;
        }
      }
    }
  #else
    while(TWCR & _BV(TWSTO)){
 404:	06 b6       	in	r0, 0x36	; 54
 406:	04 fc       	sbrc	r0, 4
 408:	fd cf       	rjmp	.-6      	; 0x404 <twi_stop+0x4>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:462
      continue;
    }
  #endif

  // update twi state
  twi_state = TWI_READY;
 40a:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <twi_state>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:463
}
 40e:	08 95       	ret

00000410 <twi_transmit>:
twi_transmit():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:371
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < (twi_txBufferLength+length)){
 410:	20 91 a9 00 	lds	r18, 0x00A9	; 0x8000a9 <twi_txBufferLength>
 414:	26 0f       	add	r18, r22
 416:	33 27       	eor	r19, r19
 418:	33 1f       	adc	r19, r19
 41a:	21 32       	cpi	r18, 0x21	; 33
 41c:	31 05       	cpc	r19, r1
 41e:	ec f4       	brge	.+58     	; 0x45a <twi_transmit+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:376
    return 1;
  }

  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
 420:	20 91 cd 00 	lds	r18, 0x00CD	; 0x8000cd <twi_state>
 424:	fc 01       	movw	r30, r24
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	80 e0       	ldi	r24, 0x00	; 0
 42a:	24 30       	cpi	r18, 0x04	; 4
 42c:	69 f0       	breq	.+26     	; 0x448 <twi_transmit+0x38>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:377
    return 2;
 42e:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:387
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;

  return 0;
}
 430:	08 95       	ret
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:382
    return 2;
  }

  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
    twi_txBuffer[twi_txBufferLength+i] = data[i];
 432:	a0 91 a9 00 	lds	r26, 0x00A9	; 0x8000a9 <twi_txBufferLength>
 436:	21 91       	ld	r18, Z+
 438:	ac 01       	movw	r20, r24
 43a:	47 57       	subi	r20, 0x77	; 119
 43c:	5f 4f       	sbci	r21, 0xFF	; 255
 43e:	a4 0f       	add	r26, r20
 440:	b5 2f       	mov	r27, r21
 442:	b1 1d       	adc	r27, r1
 444:	2c 93       	st	X, r18
 446:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:381
  if(TWI_STX != twi_state){
    return 2;
  }

  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
 448:	86 17       	cp	r24, r22
 44a:	98 f3       	brcs	.-26     	; 0x432 <twi_transmit+0x22>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:384
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
 44c:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <twi_txBufferLength>
 450:	68 0f       	add	r22, r24
 452:	60 93 a9 00 	sts	0x00A9, r22	; 0x8000a9 <twi_txBufferLength>
 456:	80 e0       	ldi	r24, 0x00	; 0
 458:	08 95       	ret
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:372
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < (twi_txBufferLength+length)){
    return 1;
 45a:	81 e0       	ldi	r24, 0x01	; 1
 45c:	08 95       	ret

0000045e <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:326
}

void TwoWire::flush(void)
{
  // XXX: to be implemented.
}
 45e:	08 95       	ret

00000460 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:321
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
 460:	8f ef       	ldi	r24, 0xFF	; 255
 462:	9f ef       	ldi	r25, 0xFF	; 255
 464:	08 95       	ret

00000466 <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:307
    value = rxBuffer[rxBufferIndex];
    ++rxBufferIndex;
  }

  return value;
}
 466:	8f ef       	ldi	r24, 0xFF	; 255
 468:	9f ef       	ldi	r25, 0xFF	; 255
 46a:	08 95       	ret

0000046c <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:290
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
 46c:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <TwoWire::rxBufferIndex>
 470:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:291
}
 472:	91 95       	neg	r25
 474:	81 95       	neg	r24
 476:	91 09       	sbc	r25, r1
 478:	08 95       	ret

0000047a <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:271

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 47a:	cf 93       	push	r28
 47c:	df 93       	push	r29
 47e:	cb 01       	movw	r24, r22
 480:	ea 01       	movw	r28, r20
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:280
      write(data[i]);
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
 482:	64 2f       	mov	r22, r20
 484:	c5 df       	rcall	.-118    	; 0x410 <twi_transmit>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:283
  }
  return quantity;
}
 486:	ce 01       	movw	r24, r28
 488:	df 91       	pop	r29
 48a:	cf 91       	pop	r28
 48c:	08 95       	ret

0000048e <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:246

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
 48e:	cf 93       	push	r28
 490:	df 93       	push	r29
 492:	1f 92       	push	r1
 494:	cd b7       	in	r28, 0x3d	; 61
 496:	de b7       	in	r29, 0x3e	; 62
 498:	69 83       	std	Y+1, r22	; 0x01
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:262
    // update amount in buffer
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
 49a:	61 e0       	ldi	r22, 0x01	; 1
 49c:	ce 01       	movw	r24, r28
 49e:	01 96       	adiw	r24, 0x01	; 1
 4a0:	b7 df       	rcall	.-146    	; 0x410 <twi_transmit>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:265
  }
  return 1;
}
 4a2:	81 e0       	ldi	r24, 0x01	; 1
 4a4:	90 e0       	ldi	r25, 0x00	; 0
 4a6:	0f 90       	pop	r0
 4a8:	df 91       	pop	r29
 4aa:	cf 91       	pop	r28
 4ac:	08 95       	ret

000004ae <Print::availableForWrite()>:
_ZN5Print17availableForWriteEv():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.h:63
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	80 e0       	ldi	r24, 0x00	; 0
 4b2:	08 95       	ret

000004b4 <Print::write(char const*) [clone .part.2] [clone .constprop.26]>:
_ZN5Print5writeEPKc.part.2.constprop.26():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.h:54
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 4b4:	fc 01       	movw	r30, r24
 4b6:	01 90       	ld	r0, Z+
 4b8:	00 20       	and	r0, r0
 4ba:	e9 f7       	brne	.-6      	; 0x4b6 <Print::write(char const*) [clone .part.2] [clone .constprop.26]+0x2>
 4bc:	31 97       	sbiw	r30, 0x01	; 1
 4be:	af 01       	movw	r20, r30
 4c0:	48 1b       	sub	r20, r24
 4c2:	59 0b       	sbc	r21, r25
 4c4:	bc 01       	movw	r22, r24
 4c6:	8e ed       	ldi	r24, 0xDE	; 222
 4c8:	90 e0       	ldi	r25, 0x00	; 0
 4ca:	94 ce       	rjmp	.-728    	; 0x1f4 <Print::write(unsigned char const*, unsigned int)>

000004cc <__vector_9>:
__vector_9():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:159
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 4cc:	1f 92       	push	r1
 4ce:	0f 92       	push	r0
 4d0:	0f b6       	in	r0, 0x3f	; 63
 4d2:	0f 92       	push	r0
 4d4:	11 24       	eor	r1, r1
 4d6:	2f 93       	push	r18
 4d8:	3f 93       	push	r19
 4da:	8f 93       	push	r24
 4dc:	9f 93       	push	r25
 4de:	af 93       	push	r26
 4e0:	bf 93       	push	r27
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:167
  static unsigned char timer0_exact = 0;
#endif

  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access, so this saves time)
  unsigned long m = timer0_millis;
 4e2:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <timer0_millis>
 4e6:	90 91 d7 00 	lds	r25, 0x00D7	; 0x8000d7 <timer0_millis+0x1>
 4ea:	a0 91 d8 00 	lds	r26, 0x00D8	; 0x8000d8 <timer0_millis+0x2>
 4ee:	b0 91 d9 00 	lds	r27, 0x00D9	; 0x8000d9 <timer0_millis+0x3>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:168
  unsigned char f = timer0_fract;
 4f2:	30 91 d5 00 	lds	r19, 0x00D5	; 0x8000d5 <timer0_fract>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:170

  f += FRACT_INC FRACT_INC_PLUS;
 4f6:	23 e0       	ldi	r18, 0x03	; 3
 4f8:	23 0f       	add	r18, r19
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:200
    ++f;
  }
#endif
#endif // CORRECT_EXACT_MILLIS

  if (f >= FRACT_MAX) {
 4fa:	2d 37       	cpi	r18, 0x7D	; 125
 4fc:	68 f1       	brcs	.+90     	; 0x558 <__vector_9+0x8c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:201
    f -= FRACT_MAX;
 4fe:	26 e8       	ldi	r18, 0x86	; 134
 500:	23 0f       	add	r18, r19
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:202
    m += MILLIS_INC + 1;
 502:	02 96       	adiw	r24, 0x02	; 2
 504:	a1 1d       	adc	r26, r1
 506:	b1 1d       	adc	r27, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:208
  }
  else {
    m += MILLIS_INC;
  }

  timer0_fract = f;
 508:	20 93 d5 00 	sts	0x00D5, r18	; 0x8000d5 <timer0_fract>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:209
  timer0_millis = m;
 50c:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <timer0_millis>
 510:	90 93 d7 00 	sts	0x00D7, r25	; 0x8000d7 <timer0_millis+0x1>
 514:	a0 93 d8 00 	sts	0x00D8, r26	; 0x8000d8 <timer0_millis+0x2>
 518:	b0 93 d9 00 	sts	0x00D9, r27	; 0x8000d9 <timer0_millis+0x3>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:211
#ifndef CORRECT_EXACT_MICROS
  timer0_overflow_count++;
 51c:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <timer0_overflow_count>
 520:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <timer0_overflow_count+0x1>
 524:	a0 91 dc 00 	lds	r26, 0x00DC	; 0x8000dc <timer0_overflow_count+0x2>
 528:	b0 91 dd 00 	lds	r27, 0x00DD	; 0x8000dd <timer0_overflow_count+0x3>
 52c:	01 96       	adiw	r24, 0x01	; 1
 52e:	a1 1d       	adc	r26, r1
 530:	b1 1d       	adc	r27, r1
 532:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <timer0_overflow_count>
 536:	90 93 db 00 	sts	0x00DB, r25	; 0x8000db <timer0_overflow_count+0x1>
 53a:	a0 93 dc 00 	sts	0x00DC, r26	; 0x8000dc <timer0_overflow_count+0x2>
 53e:	b0 93 dd 00 	sts	0x00DD, r27	; 0x8000dd <timer0_overflow_count+0x3>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:213
#endif
}
 542:	bf 91       	pop	r27
 544:	af 91       	pop	r26
 546:	9f 91       	pop	r25
 548:	8f 91       	pop	r24
 54a:	3f 91       	pop	r19
 54c:	2f 91       	pop	r18
 54e:	0f 90       	pop	r0
 550:	0f be       	out	0x3f, r0	; 63
 552:	0f 90       	pop	r0
 554:	1f 90       	pop	r1
 556:	18 95       	reti
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:205
  if (f >= FRACT_MAX) {
    f -= FRACT_MAX;
    m += MILLIS_INC + 1;
  }
  else {
    m += MILLIS_INC;
 558:	01 96       	adiw	r24, 0x01	; 1
 55a:	a1 1d       	adc	r26, r1
 55c:	b1 1d       	adc	r27, r1
 55e:	d4 cf       	rjmp	.-88     	; 0x508 <__vector_9+0x3c>

00000560 <__vector_12>:
__vector_12():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:63
#elif defined(USART0_UDRE_vect)
ISR(USART0_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 560:	1f 92       	push	r1
 562:	0f 92       	push	r0
 564:	0f b6       	in	r0, 0x3f	; 63
 566:	0f 92       	push	r0
 568:	11 24       	eor	r1, r1
 56a:	2f 93       	push	r18
 56c:	3f 93       	push	r19
 56e:	4f 93       	push	r20
 570:	5f 93       	push	r21
 572:	6f 93       	push	r22
 574:	7f 93       	push	r23
 576:	8f 93       	push	r24
 578:	9f 93       	push	r25
 57a:	af 93       	push	r26
 57c:	bf 93       	push	r27
 57e:	ef 93       	push	r30
 580:	ff 93       	push	r31
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:64
  Serial._tx_udr_empty_irq();
 582:	8e ed       	ldi	r24, 0xDE	; 222
 584:	90 e0       	ldi	r25, 0x00	; 0
 586:	b1 de       	rcall	.-670    	; 0x2ea <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:65
}
 588:	ff 91       	pop	r31
 58a:	ef 91       	pop	r30
 58c:	bf 91       	pop	r27
 58e:	af 91       	pop	r26
 590:	9f 91       	pop	r25
 592:	8f 91       	pop	r24
 594:	7f 91       	pop	r23
 596:	6f 91       	pop	r22
 598:	5f 91       	pop	r21
 59a:	4f 91       	pop	r20
 59c:	3f 91       	pop	r19
 59e:	2f 91       	pop	r18
 5a0:	0f 90       	pop	r0
 5a2:	0f be       	out	0x3f, r0	; 63
 5a4:	0f 90       	pop	r0
 5a6:	1f 90       	pop	r1
 5a8:	18 95       	reti

000005aa <__vector_11>:
__vector_11():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:50
#elif defined(USART_RX_vect)
  ISR(USART_RX_vect)
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 5aa:	1f 92       	push	r1
 5ac:	0f 92       	push	r0
 5ae:	0f b6       	in	r0, 0x3f	; 63
 5b0:	0f 92       	push	r0
 5b2:	11 24       	eor	r1, r1
 5b4:	2f 93       	push	r18
 5b6:	8f 93       	push	r24
 5b8:	9f 93       	push	r25
 5ba:	ef 93       	push	r30
 5bc:	ff 93       	push	r31
_rx_complete_irq():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:100

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 5be:	e0 91 ee 00 	lds	r30, 0x00EE	; 0x8000ee <Serial+0x10>
 5c2:	f0 91 ef 00 	lds	r31, 0x00EF	; 0x8000ef <Serial+0x11>
 5c6:	80 81       	ld	r24, Z
 5c8:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <Serial+0x16>
 5cc:	f0 91 f5 00 	lds	r31, 0x00F5	; 0x8000f5 <Serial+0x17>
 5d0:	82 fd       	sbrc	r24, 2
 5d2:	1b c0       	rjmp	.+54     	; 0x60a <__vector_11+0x60>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:103
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 5d4:	90 81       	ld	r25, Z
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:104
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 5d6:	80 91 f7 00 	lds	r24, 0x00F7	; 0x8000f7 <Serial+0x19>
 5da:	8f 5f       	subi	r24, 0xFF	; 255
 5dc:	8f 73       	andi	r24, 0x3F	; 63
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:110

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 5de:	20 91 f8 00 	lds	r18, 0x00F8	; 0x8000f8 <Serial+0x1a>
 5e2:	82 17       	cp	r24, r18
 5e4:	41 f0       	breq	.+16     	; 0x5f6 <__vector_11+0x4c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:111
      _rx_buffer[_rx_buffer_head] = c;
 5e6:	e0 91 f7 00 	lds	r30, 0x00F7	; 0x8000f7 <Serial+0x19>
 5ea:	f0 e0       	ldi	r31, 0x00	; 0
 5ec:	e2 52       	subi	r30, 0x22	; 34
 5ee:	ff 4f       	sbci	r31, 0xFF	; 255
 5f0:	95 8f       	std	Z+29, r25	; 0x1d
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:112
      _rx_buffer_head = i;
 5f2:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <Serial+0x19>
__vector_11():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:52
    Serial._rx_complete_irq();
  }
 5f6:	ff 91       	pop	r31
 5f8:	ef 91       	pop	r30
 5fa:	9f 91       	pop	r25
 5fc:	8f 91       	pop	r24
 5fe:	2f 91       	pop	r18
 600:	0f 90       	pop	r0
 602:	0f be       	out	0x3f, r0	; 63
 604:	0f 90       	pop	r0
 606:	1f 90       	pop	r1
 608:	18 95       	reti
_rx_complete_irq():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:116
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 60a:	80 81       	ld	r24, Z
 60c:	f4 cf       	rjmp	.-24     	; 0x5f6 <__vector_11+0x4c>

0000060e <__vector_17>:
__vector_17():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:534
  }
  return(flag);
}

ISR(TWI_vect)
{
 60e:	1f 92       	push	r1
 610:	0f 92       	push	r0
 612:	0f b6       	in	r0, 0x3f	; 63
 614:	0f 92       	push	r0
 616:	11 24       	eor	r1, r1
 618:	2f 93       	push	r18
 61a:	3f 93       	push	r19
 61c:	4f 93       	push	r20
 61e:	5f 93       	push	r21
 620:	6f 93       	push	r22
 622:	7f 93       	push	r23
 624:	8f 93       	push	r24
 626:	9f 93       	push	r25
 628:	af 93       	push	r26
 62a:	bf 93       	push	r27
 62c:	ef 93       	push	r30
 62e:	ff 93       	push	r31
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  switch(TW_STATUS){
 630:	81 b1       	in	r24, 0x01	; 1
 632:	88 7f       	andi	r24, 0xF8	; 248
 634:	80 36       	cpi	r24, 0x60	; 96
 636:	09 f4       	brne	.+2      	; 0x63a <__vector_17+0x2c>
 638:	49 c0       	rjmp	.+146    	; 0x6cc <__vector_17+0xbe>
 63a:	e8 f5       	brcc	.+122    	; 0x6b6 <__vector_17+0xa8>
 63c:	88 32       	cpi	r24, 0x28	; 40
 63e:	09 f4       	brne	.+2      	; 0x642 <__vector_17+0x34>
 640:	a0 c0       	rjmp	.+320    	; 0x782 <__vector_17+0x174>
 642:	18 f5       	brcc	.+70     	; 0x68a <__vector_17+0x7c>
 644:	80 31       	cpi	r24, 0x10	; 16
 646:	09 f4       	brne	.+2      	; 0x64a <__vector_17+0x3c>
 648:	96 c0       	rjmp	.+300    	; 0x776 <__vector_17+0x168>
 64a:	b8 f4       	brcc	.+46     	; 0x67a <__vector_17+0x6c>
 64c:	88 23       	and	r24, r24
 64e:	09 f4       	brne	.+2      	; 0x652 <__vector_17+0x44>
 650:	e6 c0       	rjmp	.+460    	; 0x81e <__vector_17+0x210>
 652:	88 30       	cpi	r24, 0x08	; 8
 654:	09 f4       	brne	.+2      	; 0x658 <__vector_17+0x4a>
 656:	8f c0       	rjmp	.+286    	; 0x776 <__vector_17+0x168>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:696
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
      break;
  }
}
 658:	ff 91       	pop	r31
 65a:	ef 91       	pop	r30
 65c:	bf 91       	pop	r27
 65e:	af 91       	pop	r26
 660:	9f 91       	pop	r25
 662:	8f 91       	pop	r24
 664:	7f 91       	pop	r23
 666:	6f 91       	pop	r22
 668:	5f 91       	pop	r21
 66a:	4f 91       	pop	r20
 66c:	3f 91       	pop	r19
 66e:	2f 91       	pop	r18
 670:	0f 90       	pop	r0
 672:	0f be       	out	0x3f, r0	; 63
 674:	0f 90       	pop	r0
 676:	1f 90       	pop	r1
 678:	18 95       	reti
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 67a:	88 31       	cpi	r24, 0x18	; 24
 67c:	09 f4       	brne	.+2      	; 0x680 <__vector_17+0x72>
 67e:	81 c0       	rjmp	.+258    	; 0x782 <__vector_17+0x174>
 680:	80 32       	cpi	r24, 0x20	; 32
 682:	51 f7       	brne	.-44     	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:570
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
 684:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <twi_error>
 688:	14 c0       	rjmp	.+40     	; 0x6b2 <__vector_17+0xa4>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 68a:	80 34       	cpi	r24, 0x40	; 64
 68c:	09 f4       	brne	.+2      	; 0x690 <__vector_17+0x82>
 68e:	91 c0       	rjmp	.+290    	; 0x7b2 <__vector_17+0x1a4>
 690:	40 f4       	brcc	.+16     	; 0x6a2 <__vector_17+0x94>
 692:	80 33       	cpi	r24, 0x30	; 48
 694:	b9 f3       	breq	.-18     	; 0x684 <__vector_17+0x76>
 696:	88 33       	cpi	r24, 0x38	; 56
 698:	f9 f6       	brne	.-66     	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:574
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
 69a:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <twi_error>
twi_reply():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 69e:	85 ec       	ldi	r24, 0xC5	; 197
 6a0:	a1 c0       	rjmp	.+322    	; 0x7e4 <__vector_17+0x1d6>
__vector_17():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 6a2:	80 35       	cpi	r24, 0x50	; 80
 6a4:	09 f4       	brne	.+2      	; 0x6a8 <__vector_17+0x9a>
 6a6:	7c c0       	rjmp	.+248    	; 0x7a0 <__vector_17+0x192>
 6a8:	88 35       	cpi	r24, 0x58	; 88
 6aa:	09 f4       	brne	.+2      	; 0x6ae <__vector_17+0xa0>
 6ac:	8a c0       	rjmp	.+276    	; 0x7c2 <__vector_17+0x1b4>
 6ae:	88 34       	cpi	r24, 0x48	; 72
 6b0:	99 f6       	brne	.-90     	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:693
    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
 6b2:	a6 de       	rcall	.-692    	; 0x400 <twi_stop>
 6b4:	d1 cf       	rjmp	.-94     	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 6b6:	88 39       	cpi	r24, 0x98	; 152
 6b8:	09 f4       	brne	.+2      	; 0x6bc <__vector_17+0xae>
 6ba:	81 c0       	rjmp	.+258    	; 0x7be <__vector_17+0x1b0>
 6bc:	30 f5       	brcc	.+76     	; 0x70a <__vector_17+0xfc>
 6be:	88 37       	cpi	r24, 0x78	; 120
 6c0:	29 f0       	breq	.+10     	; 0x6cc <__vector_17+0xbe>
 6c2:	50 f4       	brcc	.+20     	; 0x6d8 <__vector_17+0xca>
 6c4:	88 36       	cpi	r24, 0x68	; 104
 6c6:	11 f0       	breq	.+4      	; 0x6cc <__vector_17+0xbe>
 6c8:	80 37       	cpi	r24, 0x70	; 112
 6ca:	31 f6       	brne	.-116    	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:616
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
 6cc:	83 e0       	ldi	r24, 0x03	; 3
 6ce:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <twi_state>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:618
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
 6d2:	10 92 cb 00 	sts	0x00CB, r1	; 0x8000cb <twi_rxBufferIndex>
 6d6:	52 c0       	rjmp	.+164    	; 0x77c <__vector_17+0x16e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 6d8:	88 38       	cpi	r24, 0x88	; 136
 6da:	09 f4       	brne	.+2      	; 0x6de <__vector_17+0xd0>
 6dc:	70 c0       	rjmp	.+224    	; 0x7be <__vector_17+0x1b0>
 6de:	80 39       	cpi	r24, 0x90	; 144
 6e0:	19 f0       	breq	.+6      	; 0x6e8 <__vector_17+0xda>
 6e2:	80 38       	cpi	r24, 0x80	; 128
 6e4:	09 f0       	breq	.+2      	; 0x6e8 <__vector_17+0xda>
 6e6:	b8 cf       	rjmp	.-144    	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:624
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_SIZE){
 6e8:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <twi_rxBufferIndex>
 6ec:	80 32       	cpi	r24, 0x20	; 32
 6ee:	08 f0       	brcs	.+2      	; 0x6f2 <__vector_17+0xe4>
 6f0:	66 c0       	rjmp	.+204    	; 0x7be <__vector_17+0x1b0>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:626
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
 6f2:	e0 91 cb 00 	lds	r30, 0x00CB	; 0x8000cb <twi_rxBufferIndex>
 6f6:	81 e0       	ldi	r24, 0x01	; 1
 6f8:	8e 0f       	add	r24, r30
 6fa:	80 93 cb 00 	sts	0x00CB, r24	; 0x8000cb <twi_rxBufferIndex>
 6fe:	83 b1       	in	r24, 0x03	; 3
 700:	f0 e0       	ldi	r31, 0x00	; 0
 702:	e5 55       	subi	r30, 0x55	; 85
 704:	ff 4f       	sbci	r31, 0xFF	; 255
 706:	80 83       	st	Z, r24
 708:	39 c0       	rjmp	.+114    	; 0x77c <__vector_17+0x16e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 70a:	80 3b       	cpi	r24, 0xB0	; 176
 70c:	39 f0       	breq	.+14     	; 0x71c <__vector_17+0x10e>
 70e:	d0 f4       	brcc	.+52     	; 0x744 <__vector_17+0x136>
 710:	80 3a       	cpi	r24, 0xA0	; 160
 712:	09 f4       	brne	.+2      	; 0x716 <__vector_17+0x108>
 714:	6b c0       	rjmp	.+214    	; 0x7ec <__vector_17+0x1de>
 716:	88 3a       	cpi	r24, 0xA8	; 168
 718:	09 f0       	breq	.+2      	; 0x71c <__vector_17+0x10e>
 71a:	9e cf       	rjmp	.-196    	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:655

    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
 71c:	84 e0       	ldi	r24, 0x04	; 4
 71e:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <twi_state>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:657
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
 722:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <twi_txBufferIndex>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:659
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
 726:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <twi_txBufferLength>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:662
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
 72a:	f0 e0       	ldi	r31, 0x00	; 0
 72c:	e0 e0       	ldi	r30, 0x00	; 0
 72e:	09 95       	icall
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:664
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
 730:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <twi_txBufferLength>
 734:	81 11       	cpse	r24, r1
 736:	0f c0       	rjmp	.+30     	; 0x756 <__vector_17+0x148>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:665
        twi_txBufferLength = 1;
 738:	81 e0       	ldi	r24, 0x01	; 1
 73a:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <twi_txBufferLength>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:666
        twi_txBuffer[0] = 0x00;
 73e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <twi_txBuffer>
 742:	09 c0       	rjmp	.+18     	; 0x756 <__vector_17+0x148>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 744:	80 3c       	cpi	r24, 0xC0	; 192
 746:	09 f4       	brne	.+2      	; 0x74a <__vector_17+0x13c>
 748:	aa cf       	rjmp	.-172    	; 0x69e <__vector_17+0x90>
 74a:	88 3c       	cpi	r24, 0xC8	; 200
 74c:	09 f4       	brne	.+2      	; 0x750 <__vector_17+0x142>
 74e:	a7 cf       	rjmp	.-178    	; 0x69e <__vector_17+0x90>
 750:	88 3b       	cpi	r24, 0xB8	; 184
 752:	09 f0       	breq	.+2      	; 0x756 <__vector_17+0x148>
 754:	81 cf       	rjmp	.-254    	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:672
      }
      // transmit first byte from buffer, fall
      /* fall through */
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
 756:	e0 91 aa 00 	lds	r30, 0x00AA	; 0x8000aa <twi_txBufferIndex>
 75a:	81 e0       	ldi	r24, 0x01	; 1
 75c:	8e 0f       	add	r24, r30
 75e:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <twi_txBufferIndex>
 762:	f0 e0       	ldi	r31, 0x00	; 0
 764:	e7 57       	subi	r30, 0x77	; 119
 766:	ff 4f       	sbci	r31, 0xFF	; 255
 768:	80 81       	ld	r24, Z
 76a:	83 b9       	out	0x03, r24	; 3
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:674
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
 76c:	90 91 aa 00 	lds	r25, 0x00AA	; 0x8000aa <twi_txBufferIndex>
 770:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <twi_txBufferLength>
 774:	22 c0       	rjmp	.+68     	; 0x7ba <__vector_17+0x1ac>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:540
  switch(TW_STATUS){
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
 776:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <twi_slarw>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:550
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
 77a:	83 b9       	out	0x03, r24	; 3
twi_reply():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 77c:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:423
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 77e:	86 bf       	out	0x36, r24	; 54
 780:	6b cf       	rjmp	.-298    	; 0x658 <__vector_17+0x4a>
__vector_17():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:548

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop
      if(twi_masterBufferIndex < twi_masterBufferLength){
 782:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <twi_masterBufferIndex>
 786:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <twi_masterBufferLength>
 78a:	98 17       	cp	r25, r24
 78c:	18 f5       	brcc	.+70     	; 0x7d4 <__vector_17+0x1c6>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:550
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
 78e:	e0 91 d1 00 	lds	r30, 0x00D1	; 0x8000d1 <twi_masterBufferIndex>
 792:	81 e0       	ldi	r24, 0x01	; 1
 794:	8e 0f       	add	r24, r30
 796:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <twi_masterBufferIndex>
 79a:	f0 e0       	ldi	r31, 0x00	; 0
 79c:	80 81       	ld	r24, Z
 79e:	ed cf       	rjmp	.-38     	; 0x77a <__vector_17+0x16c>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:581
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 7a0:	e0 91 d1 00 	lds	r30, 0x00D1	; 0x8000d1 <twi_masterBufferIndex>
 7a4:	81 e0       	ldi	r24, 0x01	; 1
 7a6:	8e 0f       	add	r24, r30
 7a8:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <twi_masterBufferIndex>
 7ac:	83 b1       	in	r24, 0x03	; 3
 7ae:	f0 e0       	ldi	r31, 0x00	; 0
 7b0:	80 83       	st	Z, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:585
      /* fall through */
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
 7b2:	90 91 d1 00 	lds	r25, 0x00D1	; 0x8000d1 <twi_masterBufferIndex>
 7b6:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <twi_masterBufferLength>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:674
      /* fall through */
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
 7ba:	98 17       	cp	r25, r24
 7bc:	f8 f2       	brcs	.-66     	; 0x77c <__vector_17+0x16e>
twi_reply():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:423
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 7be:	85 e8       	ldi	r24, 0x85	; 133
 7c0:	de cf       	rjmp	.-68     	; 0x77e <__vector_17+0x170>
__vector_17():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:593
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 7c2:	e0 91 d1 00 	lds	r30, 0x00D1	; 0x8000d1 <twi_masterBufferIndex>
 7c6:	81 e0       	ldi	r24, 0x01	; 1
 7c8:	8e 0f       	add	r24, r30
 7ca:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <twi_masterBufferIndex>
 7ce:	83 b1       	in	r24, 0x03	; 3
 7d0:	f0 e0       	ldi	r31, 0x00	; 0
 7d2:	80 83       	st	Z, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:594
  if (twi_sendStop)
 7d4:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <twi_sendStop>
 7d8:	81 11       	cpse	r24, r1
 7da:	6b cf       	rjmp	.-298    	; 0x6b2 <__vector_17+0xa4>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:597
          twi_stop();
  else {
    twi_inRepStart = true;  // we're going to send the START
 7dc:	81 e0       	ldi	r24, 0x01	; 1
 7de:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <twi_inRepStart>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:601
    // don't enable the interrupt. We'll generate the start, but we
    // avoid handling the interrupt until we're in the next transaction,
    // at the point where we would normally issue the start.
    TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
 7e2:	84 ea       	ldi	r24, 0xA4	; 164
twi_reply():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 7e4:	86 bf       	out	0x36, r24	; 54
__vector_17():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:685
    case TW_ST_DATA_NACK: // received nack, we are done
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
 7e6:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <twi_state>
 7ea:	36 cf       	rjmp	.-404    	; 0x658 <__vector_17+0x4a>
twi_releaseBus():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:474
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
 7ec:	85 ec       	ldi	r24, 0xC5	; 197
 7ee:	86 bf       	out	0x36, r24	; 54
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:477

  // update twi state
  twi_state = TWI_READY;
 7f0:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <twi_state>
__vector_17():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:637
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_SIZE){
 7f4:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <twi_rxBufferIndex>
 7f8:	80 32       	cpi	r24, 0x20	; 32
 7fa:	30 f4       	brcc	.+12     	; 0x808 <__vector_17+0x1fa>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:638
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
 7fc:	e0 91 cb 00 	lds	r30, 0x00CB	; 0x8000cb <twi_rxBufferIndex>
 800:	f0 e0       	ldi	r31, 0x00	; 0
 802:	e5 55       	subi	r30, 0x55	; 85
 804:	ff 4f       	sbci	r31, 0xFF	; 255
 806:	10 82       	st	Z, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:641
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
 808:	60 91 cb 00 	lds	r22, 0x00CB	; 0x8000cb <twi_rxBufferIndex>
 80c:	70 e0       	ldi	r23, 0x00	; 0
 80e:	8b ea       	ldi	r24, 0xAB	; 171
 810:	90 e0       	ldi	r25, 0x00	; 0
 812:	f0 e0       	ldi	r31, 0x00	; 0
 814:	e0 e0       	ldi	r30, 0x00	; 0
 816:	09 95       	icall
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:643
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
 818:	10 92 cb 00 	sts	0x00CB, r1	; 0x8000cb <twi_rxBufferIndex>
 81c:	1d cf       	rjmp	.-454    	; 0x658 <__vector_17+0x4a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:692

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
 81e:	10 92 cc 00 	sts	0x00CC, r1	; 0x8000cc <twi_error>
 822:	47 cf       	rjmp	.-370    	; 0x6b2 <__vector_17+0xa4>

00000824 <global constructors keyed to 65535_0_ldr.ino.cpp.o.2518>:
_GLOBAL__I_65535_0_ldr.ino.cpp.o.2518():
 824:	0f 93       	push	r16
 826:	1f 93       	push	r17
 828:	cf 93       	push	r28
 82a:	df 93       	push	r29
 82c:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <Serial+0x3>
 830:	10 92 e0 00 	sts	0x00E0, r1	; 0x8000e0 <Serial+0x2>
 834:	88 ee       	ldi	r24, 0xE8	; 232
 836:	93 e0       	ldi	r25, 0x03	; 3
 838:	a0 e0       	ldi	r26, 0x00	; 0
 83a:	b0 e0       	ldi	r27, 0x00	; 0
 83c:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <Serial+0x4>
 840:	90 93 e3 00 	sts	0x00E3, r25	; 0x8000e3 <Serial+0x5>
 844:	a0 93 e4 00 	sts	0x00E4, r26	; 0x8000e4 <Serial+0x6>
 848:	b0 93 e5 00 	sts	0x00E5, r27	; 0x8000e5 <Serial+0x7>
 84c:	8a e6       	ldi	r24, 0x6A	; 106
 84e:	90 e0       	ldi	r25, 0x00	; 0
 850:	90 93 df 00 	sts	0x00DF, r25	; 0x8000df <Serial+0x1>
 854:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <Serial>
 858:	80 e4       	ldi	r24, 0x40	; 64
 85a:	90 e0       	ldi	r25, 0x00	; 0
 85c:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <Serial+0xd>
 860:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <Serial+0xc>
 864:	29 e2       	ldi	r18, 0x29	; 41
 866:	30 e0       	ldi	r19, 0x00	; 0
 868:	30 93 ed 00 	sts	0x00ED, r19	; 0x8000ed <Serial+0xf>
 86c:	20 93 ec 00 	sts	0x00EC, r18	; 0x8000ec <Serial+0xe>
 870:	2b e2       	ldi	r18, 0x2B	; 43
 872:	30 e0       	ldi	r19, 0x00	; 0
 874:	30 93 ef 00 	sts	0x00EF, r19	; 0x8000ef <Serial+0x11>
 878:	20 93 ee 00 	sts	0x00EE, r18	; 0x8000ee <Serial+0x10>
 87c:	2a e2       	ldi	r18, 0x2A	; 42
 87e:	30 e0       	ldi	r19, 0x00	; 0
 880:	30 93 f1 00 	sts	0x00F1, r19	; 0x8000f1 <Serial+0x13>
 884:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <Serial+0x12>
 888:	90 93 f3 00 	sts	0x00F3, r25	; 0x8000f3 <Serial+0x15>
 88c:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <Serial+0x14>
 890:	8c e2       	ldi	r24, 0x2C	; 44
 892:	90 e0       	ldi	r25, 0x00	; 0
 894:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <Serial+0x17>
 898:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <Serial+0x16>
 89c:	10 92 f7 00 	sts	0x00F7, r1	; 0x8000f7 <Serial+0x19>
 8a0:	10 92 f8 00 	sts	0x00F8, r1	; 0x8000f8 <Serial+0x1a>
 8a4:	10 92 f9 00 	sts	0x00F9, r1	; 0x8000f9 <Serial+0x1b>
 8a8:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <Serial+0x1c>
 8ac:	10 92 a1 01 	sts	0x01A1, r1	; 0x8001a1 <pixels+0x1>
 8b0:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <pixels+0x8>
 8b4:	10 92 af 01 	sts	0x01AF, r1	; 0x8001af <pixels+0xf>
 8b8:	10 92 b0 01 	sts	0x01B0, r1	; 0x8001b0 <pixels+0x10>
 8bc:	10 92 b1 01 	sts	0x01B1, r1	; 0x8001b1 <pixels+0x11>
 8c0:	10 92 b2 01 	sts	0x01B2, r1	; 0x8001b2 <pixels+0x12>
 8c4:	81 e0       	ldi	r24, 0x01	; 1
 8c6:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <pixels+0xe>
 8ca:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <pixels+0xb>
 8ce:	10 92 ac 01 	sts	0x01AC, r1	; 0x8001ac <pixels+0xc>
 8d2:	92 e0       	ldi	r25, 0x02	; 2
 8d4:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <pixels+0xd>
 8d8:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <pixels>
 8dc:	c8 e6       	ldi	r28, 0x68	; 104
 8de:	d1 e0       	ldi	r29, 0x01	; 1
 8e0:	d0 93 a5 01 	sts	0x01A5, r29	; 0x8001a5 <pixels+0x5>
 8e4:	c0 93 a4 01 	sts	0x01A4, r28	; 0x8001a4 <pixels+0x4>
 8e8:	88 e6       	ldi	r24, 0x68	; 104
 8ea:	91 e0       	ldi	r25, 0x01	; 1
 8ec:	07 d2       	rcall	.+1038   	; 0xcfc <malloc>
 8ee:	90 93 aa 01 	sts	0x01AA, r25	; 0x8001aa <pixels+0xa>
 8f2:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <pixels+0x9>
 8f6:	00 97       	sbiw	r24, 0x00	; 0
 8f8:	09 f4       	brne	.+2      	; 0x8fc <global constructors keyed to 65535_0_ldr.ino.cpp.o.2518+0xd8>
 8fa:	7e c0       	rjmp	.+252    	; 0x9f8 <global constructors keyed to 65535_0_ldr.ino.cpp.o.2518+0x1d4>
 8fc:	fc 01       	movw	r30, r24
 8fe:	9e 01       	movw	r18, r28
 900:	11 92       	st	Z+, r1
 902:	21 50       	subi	r18, 0x01	; 1
 904:	30 40       	sbci	r19, 0x00	; 0
 906:	e1 f7       	brne	.-8      	; 0x900 <global constructors keyed to 65535_0_ldr.ino.cpp.o.2518+0xdc>
 908:	88 e7       	ldi	r24, 0x78	; 120
 90a:	90 e0       	ldi	r25, 0x00	; 0
 90c:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <pixels+0x3>
 910:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <pixels+0x2>
 914:	8d e0       	ldi	r24, 0x0D	; 13
 916:	90 e0       	ldi	r25, 0x00	; 0
 918:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <pixels+0x7>
 91c:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <pixels+0x6>
 920:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <pixels+0x1>
 924:	88 23       	and	r24, r24
 926:	31 f0       	breq	.+12     	; 0x934 <global constructors keyed to 65535_0_ldr.ino.cpp.o.2518+0x110>
 928:	61 e0       	ldi	r22, 0x01	; 1
 92a:	8d e0       	ldi	r24, 0x0D	; 13
 92c:	0c dc       	rcall	.-2024   	; 0x146 <pinMode>
 92e:	60 e0       	ldi	r22, 0x00	; 0
 930:	8d e0       	ldi	r24, 0x0D	; 13
 932:	d3 db       	rcall	.-2138   	; 0xda <digitalWrite>
 934:	cf e7       	ldi	r28, 0x7F	; 127
 936:	d0 e0       	ldi	r29, 0x00	; 0
 938:	fe 01       	movw	r30, r28
 93a:	84 91       	lpm	r24, Z
 93c:	e8 2f       	mov	r30, r24
 93e:	f0 e0       	ldi	r31, 0x00	; 0
 940:	ee 0f       	add	r30, r30
 942:	ff 1f       	adc	r31, r31
 944:	e8 59       	subi	r30, 0x98	; 152
 946:	ff 4f       	sbci	r31, 0xFF	; 255
 948:	85 91       	lpm	r24, Z+
 94a:	94 91       	lpm	r25, Z
 94c:	90 93 b4 01 	sts	0x01B4, r25	; 0x8001b4 <pixels+0x14>
 950:	80 93 b3 01 	sts	0x01B3, r24	; 0x8001b3 <pixels+0x13>
 954:	0e e5       	ldi	r16, 0x5E	; 94
 956:	10 e0       	ldi	r17, 0x00	; 0
 958:	f8 01       	movw	r30, r16
 95a:	84 91       	lpm	r24, Z
 95c:	80 93 b5 01 	sts	0x01B5, r24	; 0x8001b5 <pixels+0x15>
 960:	60 e0       	ldi	r22, 0x00	; 0
 962:	8d e0       	ldi	r24, 0x0D	; 13
 964:	f0 db       	rcall	.-2080   	; 0x146 <pinMode>
 966:	f8 01       	movw	r30, r16
 968:	04 91       	lpm	r16, Z
 96a:	00 93 92 01 	sts	0x0192, r16	; 0x800192 <oneWire>
 96e:	fe 01       	movw	r30, r28
 970:	c4 91       	lpm	r28, Z
 972:	ec 2f       	mov	r30, r28
 974:	f0 e0       	ldi	r31, 0x00	; 0
 976:	ee 0f       	add	r30, r30
 978:	ff 1f       	adc	r31, r31
 97a:	e9 5b       	subi	r30, 0xB9	; 185
 97c:	ff 4f       	sbci	r31, 0xFF	; 255
 97e:	85 91       	lpm	r24, Z+
 980:	94 91       	lpm	r25, Z
 982:	90 93 94 01 	sts	0x0194, r25	; 0x800194 <oneWire+0x2>
 986:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <oneWire+0x1>
 98a:	10 92 9d 01 	sts	0x019D, r1	; 0x80019d <oneWire+0xb>
 98e:	10 92 9f 01 	sts	0x019F, r1	; 0x80019f <oneWire+0xd>
 992:	10 92 9e 01 	sts	0x019E, r1	; 0x80019e <oneWire+0xc>
 996:	10 92 9c 01 	sts	0x019C, r1	; 0x80019c <oneWire+0xa>
 99a:	10 92 9b 01 	sts	0x019B, r1	; 0x80019b <oneWire+0x9>
 99e:	10 92 9a 01 	sts	0x019A, r1	; 0x80019a <oneWire+0x8>
 9a2:	10 92 99 01 	sts	0x0199, r1	; 0x800199 <oneWire+0x7>
 9a6:	10 92 98 01 	sts	0x0198, r1	; 0x800198 <oneWire+0x6>
 9aa:	10 92 97 01 	sts	0x0197, r1	; 0x800197 <oneWire+0x5>
 9ae:	10 92 96 01 	sts	0x0196, r1	; 0x800196 <oneWire+0x4>
 9b2:	10 92 95 01 	sts	0x0195, r1	; 0x800195 <oneWire+0x3>
 9b6:	10 92 91 01 	sts	0x0191, r1	; 0x800191 <sensors+0x16>
 9ba:	10 92 90 01 	sts	0x0190, r1	; 0x800190 <sensors+0x15>
 9be:	10 92 7c 01 	sts	0x017C, r1	; 0x80017c <sensors+0x1>
 9c2:	82 e9       	ldi	r24, 0x92	; 146
 9c4:	91 e0       	ldi	r25, 0x01	; 1
 9c6:	90 93 85 01 	sts	0x0185, r25	; 0x800185 <sensors+0xa>
 9ca:	80 93 84 01 	sts	0x0184, r24	; 0x800184 <sensors+0x9>
 9ce:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <sensors+0x7>
 9d2:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <sensors+0x8>
 9d6:	10 92 7b 01 	sts	0x017B, r1	; 0x80017b <sensors>
 9da:	89 e0       	ldi	r24, 0x09	; 9
 9dc:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <sensors+0x3>
 9e0:	81 e0       	ldi	r24, 0x01	; 1
 9e2:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <sensors+0x4>
 9e6:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <sensors+0x5>
 9ea:	80 93 81 01 	sts	0x0181, r24	; 0x800181 <sensors+0x6>
 9ee:	df 91       	pop	r29
 9f0:	cf 91       	pop	r28
 9f2:	1f 91       	pop	r17
 9f4:	0f 91       	pop	r16
 9f6:	08 95       	ret
 9f8:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <pixels+0x5>
 9fc:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <pixels+0x4>
 a00:	10 92 a3 01 	sts	0x01A3, r1	; 0x8001a3 <pixels+0x3>
 a04:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <pixels+0x2>
 a08:	85 cf       	rjmp	.-246    	; 0x914 <global constructors keyed to 65535_0_ldr.ino.cpp.o.2518+0xf0>

00000a0a <main>:
main():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/main.cpp:34

//void setupUSB() __attribute__((weak));
//void setupUSB() { }

int main(void)
{
 a0a:	cf 93       	push	r28
 a0c:	df 93       	push	r29
 a0e:	cd b7       	in	r28, 0x3d	; 61
 a10:	de b7       	in	r29, 0x3e	; 62
 a12:	a1 97       	sbiw	r28, 0x21	; 33
 a14:	0f b6       	in	r0, 0x3f	; 63
 a16:	f8 94       	cli
 a18:	de bf       	out	0x3e, r29	; 62
 a1a:	0f be       	out	0x3f, r0	; 63
 a1c:	cd bf       	out	0x3d, r28	; 61
init():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:945

void init()
{
  // this needs to be called before setup() or some functions won't
  // work there
  sei();
 a1e:	78 94       	sei
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:966
#if defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__)
  // CPU specific: different values for the ATmega64/128
  TCCR0 |= _BV(WGM01) | _BV(WGM00) | _BV(CS02);
#elif defined(TCCR0) && defined(CS01) && defined(CS00)
  // This combination is for the ATmega8535, ATmega8, ATmega16, ATmega32, ATmega8515, ATmega162
  TCCR0 |= _BV(CS01) | _BV(CS00);
 a20:	83 b7       	in	r24, 0x33	; 51
 a22:	83 60       	ori	r24, 0x03	; 3
 a24:	83 bf       	out	0x33, r24	; 51
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:982
  #error Timer 0 prescale factor 64 not set correctly
#endif

// Enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
  TIMSK |= _BV(TOIE0);
 a26:	89 b7       	in	r24, 0x39	; 57
 a28:	81 60       	ori	r24, 0x01	; 1
 a2a:	89 bf       	out	0x39, r24	; 57
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:995
// this is better for motors as it ensures an even waveform
// note, however, that fast pwm mode can achieve a frequency of up
// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
  TCCR1B = _BV(CS11); // Set timer 1 prescale factor to 64
 a2c:	12 e0       	ldi	r17, 0x02	; 2
 a2e:	1e bd       	out	0x2e, r17	; 46
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:997
#if F_CPU >= 8000000L
  TCCR1B |= _BV(CS10);
 a30:	8e b5       	in	r24, 0x2e	; 46
 a32:	81 60       	ori	r24, 0x01	; 1
 a34:	8e bd       	out	0x2e, r24	; 46
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1006
#if F_CPU >= 8000000L
  TCCR1 |= _BV(CS10);
#endif
#endif
#if defined(TCCR1A) && defined(WGM10)
  TCCR1A |= _BV(WGM10); // Put timer 1 in 8-bit phase correct pwm mode
 a36:	8f b5       	in	r24, 0x2f	; 47
 a38:	81 60       	ori	r24, 0x01	; 1
 a3a:	8f bd       	out	0x2f, r24	; 47
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1011
#endif

// Set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
  TCCR2 |= _BV(CS22);
 a3c:	85 b5       	in	r24, 0x25	; 37
 a3e:	84 60       	ori	r24, 0x04	; 4
 a40:	85 bd       	out	0x25, r24	; 37
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1020
  TCCR2A |= _BV(CS22);
#endif

// Configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
  TCCR2 |= _BV(WGM20);
 a42:	85 b5       	in	r24, 0x25	; 37
 a44:	80 64       	ori	r24, 0x40	; 64
 a46:	85 bd       	out	0x25, r24	; 37
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1050
#endif

#if defined(ADCSRA)
  // set a2d prescaler so we are inside the desired 50-200 KHz range.
  #if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADEN);
 a48:	87 e8       	ldi	r24, 0x87	; 135
 a4a:	86 b9       	out	0x06, r24	; 6
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1068

  // The bootloader connects pins 0 and 1 to the USART; disconnect them
  // here so they can be used as normal digital i/o; they will be
  // reconnected in Serial.begin()
#if defined(UCSRB)
  UCSRB = 0;
 a4c:	1a b8       	out	0x0a, r1	; 10
setup():
C:\Users\Lenovo\Desktop\mindCloud\last_prject_mind\ARDUINO_IDE_CODE\ldr\ldr/ldr.ino:10

int input = 0;
int output = 0;
void setup() {
  // put your setup code here, to run once:
  pinMode(ldr, INPUT);
 a4e:	60 e0       	ldi	r22, 0x00	; 0
 a50:	81 e1       	ldi	r24, 0x11	; 17
 a52:	79 db       	rcall	.-2318   	; 0x146 <pinMode>
C:\Users\Lenovo\Desktop\mindCloud\last_prject_mind\ARDUINO_IDE_CODE\ldr\ldr/ldr.ino:11
  pinMode(led, OUTPUT);
 a54:	61 e0       	ldi	r22, 0x01	; 1
 a56:	8a e0       	ldi	r24, 0x0A	; 10
 a58:	76 db       	rcall	.-2324   	; 0x146 <pinMode>
begin():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:121

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
 a5a:	e0 91 ee 00 	lds	r30, 0x00EE	; 0x8000ee <Serial+0x10>
 a5e:	f0 91 ef 00 	lds	r31, 0x00EF	; 0x8000ef <Serial+0x11>
 a62:	10 83       	st	Z, r17
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:135
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 a64:	e0 91 ea 00 	lds	r30, 0x00EA	; 0x8000ea <Serial+0xc>
 a68:	f0 91 eb 00 	lds	r31, 0x00EB	; 0x8000eb <Serial+0xd>
 a6c:	10 82       	st	Z, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:136
  *_ubrrl = baud_setting;
 a6e:	e0 91 ec 00 	lds	r30, 0x00EC	; 0x8000ec <Serial+0xe>
 a72:	f0 91 ed 00 	lds	r31, 0x00ED	; 0x8000ed <Serial+0xf>
 a76:	8f ec       	ldi	r24, 0xCF	; 207
 a78:	80 83       	st	Z, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:138

  _written = false;
 a7a:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <Serial+0x18>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:146
#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega8515__) || defined(__AVR_ATmega162__) \
|| defined(__AVR_ATmega8535__) || defined(__AVR_ATmega16__)|| defined(__AVR_ATmega32__)   \
|| defined(__AVR_ATmega162__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
 a7e:	e0 91 f2 00 	lds	r30, 0x00F2	; 0x8000f2 <Serial+0x14>
 a82:	f0 91 f3 00 	lds	r31, 0x00F3	; 0x8000f3 <Serial+0x15>
 a86:	86 e8       	ldi	r24, 0x86	; 134
 a88:	80 83       	st	Z, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:148
  
  *_ucsrb |= _BV(RXEN0) | _BV(TXEN0) | _BV(RXCIE0);
 a8a:	e0 91 f0 00 	lds	r30, 0x00F0	; 0x8000f0 <Serial+0x12>
 a8e:	f0 91 f1 00 	lds	r31, 0x00F1	; 0x8000f1 <Serial+0x13>
 a92:	80 81       	ld	r24, Z
 a94:	88 69       	ori	r24, 0x98	; 152
 a96:	80 83       	st	Z, r24
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:149
  *_ucsrb &= ~_BV(UDRIE0);
 a98:	e0 91 f0 00 	lds	r30, 0x00F0	; 0x8000f0 <Serial+0x12>
 a9c:	f0 91 f1 00 	lds	r31, 0x00F1	; 0x8000f1 <Serial+0x13>
 aa0:	80 81       	ld	r24, Z
 aa2:	8f 7d       	andi	r24, 0xDF	; 223
 aa4:	80 83       	st	Z, r24
printNumber():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:243

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
 aa6:	9a e0       	ldi	r25, 0x0A	; 10
 aa8:	89 2e       	mov	r8, r25
 aaa:	91 2c       	mov	r9, r1
 aac:	a1 2c       	mov	r10, r1
 aae:	b1 2c       	mov	r11, r1
serialEventRun():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 ab0:	20 e0       	ldi	r18, 0x00	; 0
 ab2:	22 2e       	mov	r2, r18
 ab4:	20 e0       	ldi	r18, 0x00	; 0
 ab6:	32 2e       	mov	r3, r18
write():
 ab8:	88 e7       	ldi	r24, 0x78	; 120
 aba:	90 e0       	ldi	r25, 0x00	; 0
 abc:	fb dc       	rcall	.-1546   	; 0x4b4 <Print::write(char const*) [clone .part.2] [clone .constprop.26]>
 abe:	8e e7       	ldi	r24, 0x7E	; 126
 ac0:	90 e0       	ldi	r25, 0x00	; 0
 ac2:	f8 dc       	rcall	.-1552   	; 0x4b4 <Print::write(char const*) [clone .part.2] [clone .constprop.26]>
analogRead():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:68
  
  // set the analog reference (high two bits of ADMUX) and select the
  // channel (low 4 bits).  this also sets ADLAR (left-adjust result)
  // to 0 (the default).
#if defined(ADMUX)
  ADMUX = (analog_reference << 6) | (pin & 0x07);
 ac4:	23 e4       	ldi	r18, 0x43	; 67
 ac6:	27 b9       	out	0x07, r18	; 7
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:76
  // without a delay, we seem to read from the wrong channel
  //delay(1);

#if defined(ADCSRA) && defined(ADC)
  // start the conversion
  ADCSRA |= _BV(ADSC);
 ac8:	36 9a       	sbi	0x06, 6	; 6
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:79

  // ADSC is cleared when the conversion finishes
  while (ADCSRA & _BV(ADSC)) {};
 aca:	36 99       	sbic	0x06, 6	; 6
 acc:	fe cf       	rjmp	.-4      	; 0xaca <main+0xc0>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:83

  // ADC macro takes care of reading ADC register.
 	// avr-gcc implements the proper reading order: ADCL is read first.
 	return ADC;
 ace:	c4 b0       	in	r12, 0x04	; 4
 ad0:	d5 b0       	in	r13, 0x05	; 5
loop():
C:\Users\Lenovo\Desktop\mindCloud\last_prject_mind\ARDUINO_IDE_CODE\ldr\ldr/ldr.ino:18
}

void loop() {
  // put your main code here, to run repeatedly:
  Serial.println("hello");
  input = analogRead(ldr);
 ad2:	d0 92 d4 00 	sts	0x00D4, r13	; 0x8000d4 <input+0x1>
 ad6:	c0 92 d3 00 	sts	0x00D3, r12	; 0x8000d3 <input>
print():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:79
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
 ada:	0d 2c       	mov	r0, r13
 adc:	00 0c       	add	r0, r0
 ade:	ee 08       	sbc	r14, r14
 ae0:	ff 08       	sbc	r15, r15
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:92
size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
 ae2:	f7 fe       	sbrs	r15, 7
 ae4:	6b c0       	rjmp	.+214    	; 0xbbc <main+0x1b2>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:69
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 ae6:	6d e2       	ldi	r22, 0x2D	; 45
 ae8:	8e ed       	ldi	r24, 0xDE	; 222
 aea:	90 e0       	ldi	r25, 0x00	; 0
 aec:	1f dc       	rcall	.-1986   	; 0x32c <HardwareSerial::write(unsigned char)>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:94
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
      n = -n;
 aee:	22 27       	eor	r18, r18
 af0:	33 27       	eor	r19, r19
 af2:	a9 01       	movw	r20, r18
 af4:	2c 19       	sub	r18, r12
 af6:	3d 09       	sbc	r19, r13
 af8:	4e 09       	sbc	r20, r14
 afa:	5f 09       	sbc	r21, r15
printNumber():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:237
size_t Print::printNumber(unsigned long n, uint8_t base)
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 afc:	19 a2       	std	Y+33, r1	; 0x21
 afe:	8e 01       	movw	r16, r28
 b00:	0f 5d       	subi	r16, 0xDF	; 223
 b02:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:244
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    n /= base;
 b04:	ca 01       	movw	r24, r20
 b06:	b9 01       	movw	r22, r18
 b08:	a5 01       	movw	r20, r10
 b0a:	94 01       	movw	r18, r8
 b0c:	bd d0       	rcall	.+378    	; 0xc88 <__udivmodsi4>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:246

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 b0e:	60 5d       	subi	r22, 0xD0	; 208
 b10:	f8 01       	movw	r30, r16
 b12:	62 93       	st	-Z, r22
 b14:	8f 01       	movw	r16, r30
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:247
  } while(n);
 b16:	21 15       	cp	r18, r1
 b18:	31 05       	cpc	r19, r1
 b1a:	41 05       	cpc	r20, r1
 b1c:	51 05       	cpc	r21, r1
 b1e:	91 f7       	brne	.-28     	; 0xb04 <main+0xfa>
write():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.h:53
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 b20:	01 15       	cp	r16, r1
 b22:	11 05       	cpc	r17, r1
 b24:	11 f0       	breq	.+4      	; 0xb2a <main+0x120>
 b26:	c8 01       	movw	r24, r16
 b28:	c5 dc       	rcall	.-1654   	; 0x4b4 <Print::write(char const*) [clone .part.2] [clone .constprop.26]>
 b2a:	8e e7       	ldi	r24, 0x7E	; 126
 b2c:	90 e0       	ldi	r25, 0x00	; 0
 b2e:	c2 dc       	rcall	.-1660   	; 0x4b4 <Print::write(char const*) [clone .part.2] [clone .constprop.26]>
delay():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:397
#endif // 0
}

void delay(unsigned long ms)
{
  unsigned long start = micros();
 b30:	3b db       	rcall	.-2442   	; 0x1a8 <micros>
 b32:	2b 01       	movw	r4, r22
 b34:	3c 01       	movw	r6, r24
 b36:	88 ee       	ldi	r24, 0xE8	; 232
 b38:	c8 2e       	mov	r12, r24
 b3a:	83 e0       	ldi	r24, 0x03	; 3
 b3c:	d8 2e       	mov	r13, r24
 b3e:	e1 2c       	mov	r14, r1
 b40:	f1 2c       	mov	r15, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:401

  while (ms > 0UL) {
    yield();
    while (ms > 0UL && (micros() - start) >= 1000UL) {
 b42:	32 db       	rcall	.-2460   	; 0x1a8 <micros>
 b44:	64 19       	sub	r22, r4
 b46:	75 09       	sbc	r23, r5
 b48:	86 09       	sbc	r24, r6
 b4a:	97 09       	sbc	r25, r7
 b4c:	68 3e       	cpi	r22, 0xE8	; 232
 b4e:	73 40       	sbci	r23, 0x03	; 3
 b50:	81 05       	cpc	r24, r1
 b52:	91 05       	cpc	r25, r1
 b54:	b0 f3       	brcs	.-20     	; 0xb42 <main+0x138>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:402
      ms--;
 b56:	f1 e0       	ldi	r31, 0x01	; 1
 b58:	cf 1a       	sub	r12, r31
 b5a:	d1 08       	sbc	r13, r1
 b5c:	e1 08       	sbc	r14, r1
 b5e:	f1 08       	sbc	r15, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:403
      start += 1000UL;
 b60:	28 ee       	ldi	r18, 0xE8	; 232
 b62:	42 0e       	add	r4, r18
 b64:	23 e0       	ldi	r18, 0x03	; 3
 b66:	52 1e       	adc	r5, r18
 b68:	61 1c       	adc	r6, r1
 b6a:	71 1c       	adc	r7, r1
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:401
{
  unsigned long start = micros();

  while (ms > 0UL) {
    yield();
    while (ms > 0UL && (micros() - start) >= 1000UL) {
 b6c:	c1 14       	cp	r12, r1
 b6e:	d1 04       	cpc	r13, r1
 b70:	e1 04       	cpc	r14, r1
 b72:	f1 04       	cpc	r15, r1
 b74:	31 f7       	brne	.-52     	; 0xb42 <main+0x138>
map():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/WMath.cpp:54
  return random(diff) + howsmall;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 b76:	a0 91 d3 00 	lds	r26, 0x00D3	; 0x8000d3 <input>
 b7a:	b0 91 d4 00 	lds	r27, 0x00D4	; 0x8000d4 <input+0x1>
 b7e:	2f ef       	ldi	r18, 0xFF	; 255
 b80:	30 e0       	ldi	r19, 0x00	; 0
 b82:	b0 d0       	rcall	.+352    	; 0xce4 <__usmulhisi3>
 b84:	2f ef       	ldi	r18, 0xFF	; 255
 b86:	33 e0       	ldi	r19, 0x03	; 3
 b88:	40 e0       	ldi	r20, 0x00	; 0
 b8a:	50 e0       	ldi	r21, 0x00	; 0
 b8c:	61 d0       	rcall	.+194    	; 0xc50 <__divmodsi4>
 b8e:	f2 2e       	mov	r15, r18
 b90:	e3 2e       	mov	r14, r19
loop():
C:\Users\Lenovo\Desktop\mindCloud\last_prject_mind\ARDUINO_IDE_CODE\ldr\ldr/ldr.ino:21
  Serial.println(input);
  delay(1000);
  output = map(input, 0, 1023, 0, 255);
 b92:	02 2f       	mov	r16, r18
 b94:	13 2f       	mov	r17, r19
analogWrite():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:101
  // We need to make sure the PWM output is enabled for those pins
  // that support it, as we turn it off when digitally reading or
  // writing with them.  Also, make sure the pin is in output mode
  // for consistenty with Wiring, which doesn't require a pinMode
  // call for the analog output pins.
  pinMode(pin, OUTPUT);
 b96:	61 e0       	ldi	r22, 0x01	; 1
 b98:	8a e0       	ldi	r24, 0x0A	; 10
 b9a:	d5 da       	rcall	.-2646   	; 0x146 <pinMode>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:102
  if (val == 0)
 b9c:	01 15       	cp	r16, r1
 b9e:	11 05       	cpc	r17, r1
 ba0:	11 f5       	brne	.+68     	; 0xbe6 <main+0x1dc>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:104
  {
    digitalWrite(pin, LOW);
 ba2:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:108
  }
  else if (val == 255)
  {
    digitalWrite(pin, HIGH);
 ba4:	8a e0       	ldi	r24, 0x0A	; 10
 ba6:	99 da       	rcall	.-2766   	; 0xda <digitalWrite>
serialEventRun():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:67
 ba8:	21 14       	cp	r2, r1
 baa:	31 04       	cpc	r3, r1
 bac:	09 f4       	brne	.+2      	; 0xbb0 <main+0x1a6>
 bae:	84 cf       	rjmp	.-248    	; 0xab8 <main+0xae>
 bb0:	8b db       	rcall	.-2282   	; 0x2c8 <Serial0_available()>
 bb2:	88 23       	and	r24, r24
 bb4:	09 f4       	brne	.+2      	; 0xbb8 <main+0x1ae>
 bb6:	80 cf       	rjmp	.-256    	; 0xab8 <main+0xae>
 bb8:	23 da       	rcall	.-3002   	; 0x0 <__vectors>
 bba:	7e cf       	rjmp	.-260    	; 0xab8 <main+0xae>
print():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:97
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
 bbc:	a7 01       	movw	r20, r14
 bbe:	96 01       	movw	r18, r12
printNumber():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:237
size_t Print::printNumber(unsigned long n, uint8_t base)
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 bc0:	19 a2       	std	Y+33, r1	; 0x21
 bc2:	8e 01       	movw	r16, r28
 bc4:	0f 5d       	subi	r16, 0xDF	; 223
 bc6:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:244
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    n /= base;
 bc8:	ca 01       	movw	r24, r20
 bca:	b9 01       	movw	r22, r18
 bcc:	a5 01       	movw	r20, r10
 bce:	94 01       	movw	r18, r8
 bd0:	5b d0       	rcall	.+182    	; 0xc88 <__udivmodsi4>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:246

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 bd2:	60 5d       	subi	r22, 0xD0	; 208
 bd4:	f8 01       	movw	r30, r16
 bd6:	62 93       	st	-Z, r22
 bd8:	8f 01       	movw	r16, r30
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:247
  } while(n);
 bda:	21 15       	cp	r18, r1
 bdc:	31 05       	cpc	r19, r1
 bde:	41 05       	cpc	r20, r1
 be0:	51 05       	cpc	r21, r1
 be2:	91 f7       	brne	.-28     	; 0xbc8 <main+0x1be>
 be4:	9d cf       	rjmp	.-198    	; 0xb20 <main+0x116>
analogWrite():
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:106
  pinMode(pin, OUTPUT);
  if (val == 0)
  {
    digitalWrite(pin, LOW);
  }
  else if (val == 255)
 be6:	0f 3f       	cpi	r16, 0xFF	; 255
 be8:	11 05       	cpc	r17, r1
 bea:	11 f4       	brne	.+4      	; 0xbf0 <main+0x1e6>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:108
  {
    digitalWrite(pin, HIGH);
 bec:	61 e0       	ldi	r22, 0x01	; 1
 bee:	da cf       	rjmp	.-76     	; 0xba4 <main+0x19a>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:112
  }
  else
  {
    switch(digitalPinToTimer(pin))
 bf0:	ea e3       	ldi	r30, 0x3A	; 58
 bf2:	f0 e0       	ldi	r31, 0x00	; 0
 bf4:	84 91       	lpm	r24, Z
 bf6:	85 30       	cpi	r24, 0x05	; 5
 bf8:	61 f0       	breq	.+24     	; 0xc12 <main+0x208>
 bfa:	87 30       	cpi	r24, 0x07	; 7
 bfc:	91 f0       	breq	.+36     	; 0xc22 <main+0x218>
 bfe:	84 30       	cpi	r24, 0x04	; 4
 c00:	a9 f4       	brne	.+42     	; 0xc2c <main+0x222>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:148
      #endif

      #if defined(TCCR1A) && defined(COM1A1)
      case TIMER1A:
        // connect pwm to pin on timer 1, channel A
        TCCR1A |= _BV(COM1A1);
 c02:	8f b5       	in	r24, 0x2f	; 47
 c04:	80 68       	ori	r24, 0x80	; 128
 c06:	8f bd       	out	0x2f, r24	; 47
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:149
        OCR1A = val; // set pwm duty
 c08:	8f 2d       	mov	r24, r15
 c0a:	9e 2d       	mov	r25, r14
 c0c:	9b bd       	out	0x2b, r25	; 43
 c0e:	8a bd       	out	0x2a, r24	; 42
 c10:	cb cf       	rjmp	.-106    	; 0xba8 <main+0x19e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:156
      #endif

      #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        // connect pwm to pin on timer 1, channel B
        TCCR1A |= _BV(COM1B1);
 c12:	8f b5       	in	r24, 0x2f	; 47
 c14:	80 62       	ori	r24, 0x20	; 32
 c16:	8f bd       	out	0x2f, r24	; 47
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:157
        OCR1B = val; // set pwm duty
 c18:	8f 2d       	mov	r24, r15
 c1a:	9e 2d       	mov	r25, r14
 c1c:	99 bd       	out	0x29, r25	; 41
 c1e:	88 bd       	out	0x28, r24	; 40
 c20:	c3 cf       	rjmp	.-122    	; 0xba8 <main+0x19e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:172
      #endif

      #if defined(TCCR2) && defined(COM21)
      case TIMER2:
        // connect pwm to pin on timer 2
        TCCR2 |= _BV(COM21);
 c22:	85 b5       	in	r24, 0x25	; 37
 c24:	80 62       	ori	r24, 0x20	; 32
 c26:	85 bd       	out	0x25, r24	; 37
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:173
        OCR2 = val; // set pwm duty
 c28:	f3 bc       	out	0x23, r15	; 35
 c2a:	be cf       	rjmp	.-132    	; 0xba8 <main+0x19e>
C:\Users\Lenovo\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_analog.c:292
        break;
      #endif

      case NOT_ON_TIMER:
      default:
        if (val < 128) {
 c2c:	00 38       	cpi	r16, 0x80	; 128
 c2e:	11 05       	cpc	r17, r1
 c30:	ec f6       	brge	.-70     	; 0xbec <main+0x1e2>
 c32:	b7 cf       	rjmp	.-146    	; 0xba2 <main+0x198>

00000c34 <_GLOBAL__sub_D__ZN4CingC2Ev>:
_GLOBAL__sub_D__ZN4CingC2Ev():
c:\Users\Lenovo\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:120

/*!
  @brief   Deallocate Adafruit_NeoPixel object, set data pin back to INPUT.
*/
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  free(pixels);
 c34:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <pixels+0x9>
 c38:	90 91 aa 01 	lds	r25, 0x01AA	; 0x8001aa <pixels+0xa>
 c3c:	fb d0       	rcall	.+502    	; 0xe34 <free>
c:\Users\Lenovo\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:121
  if (pin >= 0)
 c3e:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <pixels+0x6>
 c42:	90 91 a7 01 	lds	r25, 0x01A7	; 0x8001a7 <pixels+0x7>
 c46:	97 fd       	sbrc	r25, 7
 c48:	02 c0       	rjmp	.+4      	; 0xc4e <_GLOBAL__sub_D__ZN4CingC2Ev+0x1a>
c:\Users\Lenovo\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:122
    pinMode(pin, INPUT);
 c4a:	60 e0       	ldi	r22, 0x00	; 0
 c4c:	7c ca       	rjmp	.-2824   	; 0x146 <pinMode>
c:\Users\Lenovo\Documents\Arduino\libraries\Atmega8_IO\src/Atmega8_IO.cpp:296
			}
	}
void Cing::ShowLed()
	{
		pixels.show();
	}
 c4e:	08 95       	ret

00000c50 <__divmodsi4>:
__divmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
 c50:	05 2e       	mov	r0, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
 c52:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
 c54:	16 f4       	brtc	.+4      	; 0xc5a <__divmodsi4+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
 c56:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
 c58:	0f d0       	rcall	.+30     	; 0xc78 <__negsi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
 c5a:	57 fd       	sbrc	r21, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
 c5c:	05 d0       	rcall	.+10     	; 0xc68 <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
 c5e:	14 d0       	rcall	.+40     	; 0xc88 <__udivmodsi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
 c60:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
 c62:	02 d0       	rcall	.+4      	; 0xc68 <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
 c64:	46 f4       	brtc	.+16     	; 0xc76 <__divmodsi4_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
 c66:	08 c0       	rjmp	.+16     	; 0xc78 <__negsi2>

00000c68 <__divmodsi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
 c68:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
 c6a:	40 95       	com	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
 c6c:	30 95       	com	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
 c6e:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
 c70:	3f 4f       	sbci	r19, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
 c72:	4f 4f       	sbci	r20, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
 c74:	5f 4f       	sbci	r21, 0xFF	; 255

00000c76 <__divmodsi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
 c76:	08 95       	ret

00000c78 <__negsi2>:
__negsi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
 c78:	90 95       	com	r25
 c7a:	80 95       	com	r24
 c7c:	70 95       	com	r23
 c7e:	61 95       	neg	r22
 c80:	7f 4f       	sbci	r23, 0xFF	; 255
 c82:	8f 4f       	sbci	r24, 0xFF	; 255
 c84:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
 c86:	08 95       	ret

00000c88 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
 c88:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
 c8a:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
 c8c:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
 c8e:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
 c90:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
 c92:	0d c0       	rjmp	.+26     	; 0xcae <__udivmodsi4_ep>

00000c94 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
 c94:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
 c96:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
 c98:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
 c9a:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
 c9c:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
 c9e:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
 ca0:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
 ca2:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
 ca4:	20 f0       	brcs	.+8      	; 0xcae <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
 ca6:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
 ca8:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
 caa:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
 cac:	f5 0b       	sbc	r31, r21

00000cae <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
 cae:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
 cb0:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
 cb2:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
 cb4:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
 cb6:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
 cb8:	69 f7       	brne	.-38     	; 0xc94 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
 cba:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
 cbc:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
 cbe:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
 cc0:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
 cc2:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
 cc4:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
 cc6:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
 cc8:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
 cca:	08 95       	ret

00000ccc <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 ccc:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 cce:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 cd0:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 cd2:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 cd4:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:578
 cd6:	01 d0       	rcall	.+2      	; 0xcda <__umulhisi3+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 cd8:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 cda:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 cdc:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 cde:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 ce0:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 ce2:	08 95       	ret

00000ce4 <__usmulhisi3>:
__usmulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:545
 ce4:	f3 df       	rcall	.-26     	; 0xccc <__umulhisi3>

00000ce6 <__usmulhisi3_tail>:
__usmulhisi3_tail():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:551
 ce6:	b7 ff       	sbrs	r27, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:552
 ce8:	08 95       	ret
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:553
 cea:	82 1b       	sub	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:554
 cec:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:555
 cee:	08 95       	ret

00000cf0 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 cf0:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 cf2:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 cf4:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 cf6:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 cf8:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 cfa:	09 94       	ijmp

00000cfc <malloc>:
malloc():
 cfc:	0f 93       	push	r16
 cfe:	1f 93       	push	r17
 d00:	cf 93       	push	r28
 d02:	df 93       	push	r29
 d04:	82 30       	cpi	r24, 0x02	; 2
 d06:	91 05       	cpc	r25, r1
 d08:	10 f4       	brcc	.+4      	; 0xd0e <malloc+0x12>
 d0a:	82 e0       	ldi	r24, 0x02	; 2
 d0c:	90 e0       	ldi	r25, 0x00	; 0
 d0e:	e0 91 b8 01 	lds	r30, 0x01B8	; 0x8001b8 <__flp>
 d12:	f0 91 b9 01 	lds	r31, 0x01B9	; 0x8001b9 <__flp+0x1>
 d16:	30 e0       	ldi	r19, 0x00	; 0
 d18:	20 e0       	ldi	r18, 0x00	; 0
 d1a:	b0 e0       	ldi	r27, 0x00	; 0
 d1c:	a0 e0       	ldi	r26, 0x00	; 0
 d1e:	30 97       	sbiw	r30, 0x00	; 0
 d20:	99 f4       	brne	.+38     	; 0xd48 <malloc+0x4c>
 d22:	21 15       	cp	r18, r1
 d24:	31 05       	cpc	r19, r1
 d26:	09 f4       	brne	.+2      	; 0xd2a <malloc+0x2e>
 d28:	4a c0       	rjmp	.+148    	; 0xdbe <malloc+0xc2>
 d2a:	28 1b       	sub	r18, r24
 d2c:	39 0b       	sbc	r19, r25
 d2e:	24 30       	cpi	r18, 0x04	; 4
 d30:	31 05       	cpc	r19, r1
 d32:	d8 f5       	brcc	.+118    	; 0xdaa <malloc+0xae>
 d34:	8a 81       	ldd	r24, Y+2	; 0x02
 d36:	9b 81       	ldd	r25, Y+3	; 0x03
 d38:	61 15       	cp	r22, r1
 d3a:	71 05       	cpc	r23, r1
 d3c:	89 f1       	breq	.+98     	; 0xda0 <malloc+0xa4>
 d3e:	fb 01       	movw	r30, r22
 d40:	93 83       	std	Z+3, r25	; 0x03
 d42:	82 83       	std	Z+2, r24	; 0x02
 d44:	fe 01       	movw	r30, r28
 d46:	11 c0       	rjmp	.+34     	; 0xd6a <malloc+0x6e>
 d48:	40 81       	ld	r20, Z
 d4a:	51 81       	ldd	r21, Z+1	; 0x01
 d4c:	02 81       	ldd	r16, Z+2	; 0x02
 d4e:	13 81       	ldd	r17, Z+3	; 0x03
 d50:	48 17       	cp	r20, r24
 d52:	59 07       	cpc	r21, r25
 d54:	e0 f0       	brcs	.+56     	; 0xd8e <malloc+0x92>
 d56:	48 17       	cp	r20, r24
 d58:	59 07       	cpc	r21, r25
 d5a:	99 f4       	brne	.+38     	; 0xd82 <malloc+0x86>
 d5c:	10 97       	sbiw	r26, 0x00	; 0
 d5e:	61 f0       	breq	.+24     	; 0xd78 <malloc+0x7c>
 d60:	12 96       	adiw	r26, 0x02	; 2
 d62:	0c 93       	st	X, r16
 d64:	12 97       	sbiw	r26, 0x02	; 2
 d66:	13 96       	adiw	r26, 0x03	; 3
 d68:	1c 93       	st	X, r17
 d6a:	32 96       	adiw	r30, 0x02	; 2
 d6c:	cf 01       	movw	r24, r30
 d6e:	df 91       	pop	r29
 d70:	cf 91       	pop	r28
 d72:	1f 91       	pop	r17
 d74:	0f 91       	pop	r16
 d76:	08 95       	ret
 d78:	00 93 b8 01 	sts	0x01B8, r16	; 0x8001b8 <__flp>
 d7c:	10 93 b9 01 	sts	0x01B9, r17	; 0x8001b9 <__flp+0x1>
 d80:	f4 cf       	rjmp	.-24     	; 0xd6a <malloc+0x6e>
 d82:	21 15       	cp	r18, r1
 d84:	31 05       	cpc	r19, r1
 d86:	51 f0       	breq	.+20     	; 0xd9c <malloc+0xa0>
 d88:	42 17       	cp	r20, r18
 d8a:	53 07       	cpc	r21, r19
 d8c:	38 f0       	brcs	.+14     	; 0xd9c <malloc+0xa0>
 d8e:	a9 01       	movw	r20, r18
 d90:	db 01       	movw	r26, r22
 d92:	9a 01       	movw	r18, r20
 d94:	bd 01       	movw	r22, r26
 d96:	df 01       	movw	r26, r30
 d98:	f8 01       	movw	r30, r16
 d9a:	c1 cf       	rjmp	.-126    	; 0xd1e <malloc+0x22>
 d9c:	ef 01       	movw	r28, r30
 d9e:	f9 cf       	rjmp	.-14     	; 0xd92 <malloc+0x96>
 da0:	90 93 b9 01 	sts	0x01B9, r25	; 0x8001b9 <__flp+0x1>
 da4:	80 93 b8 01 	sts	0x01B8, r24	; 0x8001b8 <__flp>
 da8:	cd cf       	rjmp	.-102    	; 0xd44 <malloc+0x48>
 daa:	fe 01       	movw	r30, r28
 dac:	e2 0f       	add	r30, r18
 dae:	f3 1f       	adc	r31, r19
 db0:	81 93       	st	Z+, r24
 db2:	91 93       	st	Z+, r25
 db4:	22 50       	subi	r18, 0x02	; 2
 db6:	31 09       	sbc	r19, r1
 db8:	39 83       	std	Y+1, r19	; 0x01
 dba:	28 83       	st	Y, r18
 dbc:	d7 cf       	rjmp	.-82     	; 0xd6c <malloc+0x70>
 dbe:	20 91 b6 01 	lds	r18, 0x01B6	; 0x8001b6 <__brkval>
 dc2:	30 91 b7 01 	lds	r19, 0x01B7	; 0x8001b7 <__brkval+0x1>
 dc6:	23 2b       	or	r18, r19
 dc8:	41 f4       	brne	.+16     	; 0xdda <malloc+0xde>
 dca:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__malloc_heap_start>
 dce:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <__malloc_heap_start+0x1>
 dd2:	30 93 b7 01 	sts	0x01B7, r19	; 0x8001b7 <__brkval+0x1>
 dd6:	20 93 b6 01 	sts	0x01B6, r18	; 0x8001b6 <__brkval>
 dda:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 dde:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 de2:	21 15       	cp	r18, r1
 de4:	31 05       	cpc	r19, r1
 de6:	41 f4       	brne	.+16     	; 0xdf8 <malloc+0xfc>
 de8:	2d b7       	in	r18, 0x3d	; 61
 dea:	3e b7       	in	r19, 0x3e	; 62
 dec:	40 91 64 00 	lds	r20, 0x0064	; 0x800064 <__malloc_margin>
 df0:	50 91 65 00 	lds	r21, 0x0065	; 0x800065 <__malloc_margin+0x1>
 df4:	24 1b       	sub	r18, r20
 df6:	35 0b       	sbc	r19, r21
 df8:	e0 91 b6 01 	lds	r30, 0x01B6	; 0x8001b6 <__brkval>
 dfc:	f0 91 b7 01 	lds	r31, 0x01B7	; 0x8001b7 <__brkval+0x1>
 e00:	e2 17       	cp	r30, r18
 e02:	f3 07       	cpc	r31, r19
 e04:	a0 f4       	brcc	.+40     	; 0xe2e <malloc+0x132>
 e06:	2e 1b       	sub	r18, r30
 e08:	3f 0b       	sbc	r19, r31
 e0a:	28 17       	cp	r18, r24
 e0c:	39 07       	cpc	r19, r25
 e0e:	78 f0       	brcs	.+30     	; 0xe2e <malloc+0x132>
 e10:	ac 01       	movw	r20, r24
 e12:	4e 5f       	subi	r20, 0xFE	; 254
 e14:	5f 4f       	sbci	r21, 0xFF	; 255
 e16:	24 17       	cp	r18, r20
 e18:	35 07       	cpc	r19, r21
 e1a:	48 f0       	brcs	.+18     	; 0xe2e <malloc+0x132>
 e1c:	4e 0f       	add	r20, r30
 e1e:	5f 1f       	adc	r21, r31
 e20:	50 93 b7 01 	sts	0x01B7, r21	; 0x8001b7 <__brkval+0x1>
 e24:	40 93 b6 01 	sts	0x01B6, r20	; 0x8001b6 <__brkval>
 e28:	81 93       	st	Z+, r24
 e2a:	91 93       	st	Z+, r25
 e2c:	9f cf       	rjmp	.-194    	; 0xd6c <malloc+0x70>
 e2e:	f0 e0       	ldi	r31, 0x00	; 0
 e30:	e0 e0       	ldi	r30, 0x00	; 0
 e32:	9c cf       	rjmp	.-200    	; 0xd6c <malloc+0x70>

00000e34 <free>:
free():
 e34:	cf 93       	push	r28
 e36:	df 93       	push	r29
 e38:	00 97       	sbiw	r24, 0x00	; 0
 e3a:	e9 f0       	breq	.+58     	; 0xe76 <free+0x42>
 e3c:	fc 01       	movw	r30, r24
 e3e:	32 97       	sbiw	r30, 0x02	; 2
 e40:	13 82       	std	Z+3, r1	; 0x03
 e42:	12 82       	std	Z+2, r1	; 0x02
 e44:	a0 91 b8 01 	lds	r26, 0x01B8	; 0x8001b8 <__flp>
 e48:	b0 91 b9 01 	lds	r27, 0x01B9	; 0x8001b9 <__flp+0x1>
 e4c:	ed 01       	movw	r28, r26
 e4e:	30 e0       	ldi	r19, 0x00	; 0
 e50:	20 e0       	ldi	r18, 0x00	; 0
 e52:	10 97       	sbiw	r26, 0x00	; 0
 e54:	a1 f4       	brne	.+40     	; 0xe7e <free+0x4a>
 e56:	20 81       	ld	r18, Z
 e58:	31 81       	ldd	r19, Z+1	; 0x01
 e5a:	82 0f       	add	r24, r18
 e5c:	93 1f       	adc	r25, r19
 e5e:	20 91 b6 01 	lds	r18, 0x01B6	; 0x8001b6 <__brkval>
 e62:	30 91 b7 01 	lds	r19, 0x01B7	; 0x8001b7 <__brkval+0x1>
 e66:	28 17       	cp	r18, r24
 e68:	39 07       	cpc	r19, r25
 e6a:	09 f0       	breq	.+2      	; 0xe6e <free+0x3a>
 e6c:	61 c0       	rjmp	.+194    	; 0xf30 <free+0xfc>
 e6e:	f0 93 b7 01 	sts	0x01B7, r31	; 0x8001b7 <__brkval+0x1>
 e72:	e0 93 b6 01 	sts	0x01B6, r30	; 0x8001b6 <__brkval>
 e76:	df 91       	pop	r29
 e78:	cf 91       	pop	r28
 e7a:	08 95       	ret
 e7c:	ea 01       	movw	r28, r20
 e7e:	ce 17       	cp	r28, r30
 e80:	df 07       	cpc	r29, r31
 e82:	e8 f5       	brcc	.+122    	; 0xefe <free+0xca>
 e84:	4a 81       	ldd	r20, Y+2	; 0x02
 e86:	5b 81       	ldd	r21, Y+3	; 0x03
 e88:	9e 01       	movw	r18, r28
 e8a:	41 15       	cp	r20, r1
 e8c:	51 05       	cpc	r21, r1
 e8e:	b1 f7       	brne	.-20     	; 0xe7c <free+0x48>
 e90:	e9 01       	movw	r28, r18
 e92:	fb 83       	std	Y+3, r31	; 0x03
 e94:	ea 83       	std	Y+2, r30	; 0x02
 e96:	49 91       	ld	r20, Y+
 e98:	59 91       	ld	r21, Y+
 e9a:	c4 0f       	add	r28, r20
 e9c:	d5 1f       	adc	r29, r21
 e9e:	ec 17       	cp	r30, r28
 ea0:	fd 07       	cpc	r31, r29
 ea2:	61 f4       	brne	.+24     	; 0xebc <free+0x88>
 ea4:	80 81       	ld	r24, Z
 ea6:	91 81       	ldd	r25, Z+1	; 0x01
 ea8:	02 96       	adiw	r24, 0x02	; 2
 eaa:	84 0f       	add	r24, r20
 eac:	95 1f       	adc	r25, r21
 eae:	e9 01       	movw	r28, r18
 eb0:	99 83       	std	Y+1, r25	; 0x01
 eb2:	88 83       	st	Y, r24
 eb4:	82 81       	ldd	r24, Z+2	; 0x02
 eb6:	93 81       	ldd	r25, Z+3	; 0x03
 eb8:	9b 83       	std	Y+3, r25	; 0x03
 eba:	8a 83       	std	Y+2, r24	; 0x02
 ebc:	f0 e0       	ldi	r31, 0x00	; 0
 ebe:	e0 e0       	ldi	r30, 0x00	; 0
 ec0:	12 96       	adiw	r26, 0x02	; 2
 ec2:	8d 91       	ld	r24, X+
 ec4:	9c 91       	ld	r25, X
 ec6:	13 97       	sbiw	r26, 0x03	; 3
 ec8:	00 97       	sbiw	r24, 0x00	; 0
 eca:	b9 f5       	brne	.+110    	; 0xf3a <free+0x106>
 ecc:	2d 91       	ld	r18, X+
 ece:	3c 91       	ld	r19, X
 ed0:	11 97       	sbiw	r26, 0x01	; 1
 ed2:	cd 01       	movw	r24, r26
 ed4:	02 96       	adiw	r24, 0x02	; 2
 ed6:	82 0f       	add	r24, r18
 ed8:	93 1f       	adc	r25, r19
 eda:	20 91 b6 01 	lds	r18, 0x01B6	; 0x8001b6 <__brkval>
 ede:	30 91 b7 01 	lds	r19, 0x01B7	; 0x8001b7 <__brkval+0x1>
 ee2:	28 17       	cp	r18, r24
 ee4:	39 07       	cpc	r19, r25
 ee6:	39 f6       	brne	.-114    	; 0xe76 <free+0x42>
 ee8:	30 97       	sbiw	r30, 0x00	; 0
 eea:	51 f5       	brne	.+84     	; 0xf40 <free+0x10c>
 eec:	10 92 b9 01 	sts	0x01B9, r1	; 0x8001b9 <__flp+0x1>
 ef0:	10 92 b8 01 	sts	0x01B8, r1	; 0x8001b8 <__flp>
 ef4:	b0 93 b7 01 	sts	0x01B7, r27	; 0x8001b7 <__brkval+0x1>
 ef8:	a0 93 b6 01 	sts	0x01B6, r26	; 0x8001b6 <__brkval>
 efc:	bc cf       	rjmp	.-136    	; 0xe76 <free+0x42>
 efe:	d3 83       	std	Z+3, r29	; 0x03
 f00:	c2 83       	std	Z+2, r28	; 0x02
 f02:	40 81       	ld	r20, Z
 f04:	51 81       	ldd	r21, Z+1	; 0x01
 f06:	84 0f       	add	r24, r20
 f08:	95 1f       	adc	r25, r21
 f0a:	c8 17       	cp	r28, r24
 f0c:	d9 07       	cpc	r29, r25
 f0e:	61 f4       	brne	.+24     	; 0xf28 <free+0xf4>
 f10:	4e 5f       	subi	r20, 0xFE	; 254
 f12:	5f 4f       	sbci	r21, 0xFF	; 255
 f14:	88 81       	ld	r24, Y
 f16:	99 81       	ldd	r25, Y+1	; 0x01
 f18:	48 0f       	add	r20, r24
 f1a:	59 1f       	adc	r21, r25
 f1c:	51 83       	std	Z+1, r21	; 0x01
 f1e:	40 83       	st	Z, r20
 f20:	8a 81       	ldd	r24, Y+2	; 0x02
 f22:	9b 81       	ldd	r25, Y+3	; 0x03
 f24:	93 83       	std	Z+3, r25	; 0x03
 f26:	82 83       	std	Z+2, r24	; 0x02
 f28:	21 15       	cp	r18, r1
 f2a:	31 05       	cpc	r19, r1
 f2c:	09 f0       	breq	.+2      	; 0xf30 <free+0xfc>
 f2e:	b0 cf       	rjmp	.-160    	; 0xe90 <free+0x5c>
 f30:	f0 93 b9 01 	sts	0x01B9, r31	; 0x8001b9 <__flp+0x1>
 f34:	e0 93 b8 01 	sts	0x01B8, r30	; 0x8001b8 <__flp>
 f38:	9e cf       	rjmp	.-196    	; 0xe76 <free+0x42>
 f3a:	fd 01       	movw	r30, r26
 f3c:	dc 01       	movw	r26, r24
 f3e:	c0 cf       	rjmp	.-128    	; 0xec0 <free+0x8c>
 f40:	13 82       	std	Z+3, r1	; 0x03
 f42:	12 82       	std	Z+2, r1	; 0x02
 f44:	d7 cf       	rjmp	.-82     	; 0xef4 <free+0xc0>

00000f46 <__do_global_dtors>:
__do_global_dtors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
 f46:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
 f48:	c6 e4       	ldi	r28, 0x46	; 70
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
 f4a:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
 f4c:	03 c0       	rjmp	.+6      	; 0xf54 <__do_global_dtors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
 f4e:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
 f50:	cf de       	rcall	.-610    	; 0xcf0 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
 f52:	21 96       	adiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
 f54:	c7 34       	cpi	r28, 0x47	; 71
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
 f56:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
 f58:	d1 f7       	brne	.-12     	; 0xf4e <__do_global_dtors+0x8>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 f5a:	f8 94       	cli

00000f5c <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 f5c:	ff cf       	rjmp	.-2      	; 0xf5c <__stop_program>
